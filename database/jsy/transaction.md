# :question: 트랜잭션 (Transaction)

#### reference
https://pyoungt.tistory.com/2<br>
https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Database/Transaction%20Isolation%20Level.md
<hr>

## Question
1. [트랜잭션이란?](#1-transaction)
- 데이터베이스의 논리적 기능을 수행하기 위한 작업 단위입니다. 트랜잭션은 전체가 수행되거나, 또는 전혀 수행되지 않아야합니다.
<br><br/>

2. [트랜잭션의 성질 ACID](#1-트랜잭션의-특성-acid)
- 원자성(A), 독립성(C), 일관성(I), 지속성(D)이라고 불리는 총 4가지 성질을 가지고 있습니다.
- 원자성(Atomicity)은 트랜잭션의 연산이  **DB에 모두 반영되던지 전혀 반영되지 않던지** 둘 중에 하나만 수행해야 한다는 성질입니다.
- 일관성(Consistency)은 트랜잭션이 성공적으로 완료된 후, **언제나 일관성 있는 DB 상태로 있어야 한다**는 성질입니다.
- 독립성(Isolation)은 수행중인 트랜잭션이 **완전히 완료되기 전에는 다른 트랜잭션에서 수행 결과를 참조할 수 없다**는 성질입니다.
- 지속성(Durability)은 성공적으로 완료된 트랜잭션의 결과는 **시스템이 고장나더라도 영구적으로 반영되어야 한다**는 성질입니다. <br>(트랜잭션이 정상적으로 완료(commit)된 경우, 하드디스크(DB)에 확실히 기록해야합니다. 부분완료된 경우, 작업을 취소해야합니다.(rollback))
<br><br/>

3. [트랜잭션을 병행으로 처리할 때 발생할 수 있는 문제점과 이를 방지하기 위한 방법](#2-트랜잭션을-병행으로-처리-할-때동시성-제어의-문제점)
- 두 트랜잭션이 하나의 레코드를 갱신할 때, 하나의 트랜잭션이 롤백하면 다른 하나의 트랜잭션 마저 롤백이 되는 상황이 발생할 수 있습니다.
- 이를 방지하기 위해서, [로킹 제어 기법](#2-locking-제어-기법) 사용할 수 있습니다. <br> 로킹 제어 기법이란 트랜잭션이 DB의 데이터를 사용할 때, DB의 일정 부분을 Lock시키고 트랜잭션이 완료될 때 Lock이 된 부분을 Unlock시키는 방법입니다.
<br><br/>

4. (3-1) [Locking 제어 기법을 사용할 때 Locking 단위를 크게/작게 했을 때의 차이점](#2-로킹-단위의-차이)
- 로킹 단위가 크면 그만큼 **관리가 쉽지만, 병행성이 떨어집니다**.
- 반면, 로킹 단위가 작으면 **관리가 어렵고 오버헤드가 증가하지만, 병행성이 올라갑니다**.
<br><br/>

5. (3-2) [Locking 제어가 일으킬 수 있는 문제점](#3-로킹-제어-기법을-사용할-때-발생할-수-있는-문제점)
- 로킹단위에 따라 차이가 있지만, **트랜잭션의 직렬화 가능성이 높아집니다**. 즉, 병행처리를 해도 성능의 차이가 없을 수 있습니다.
- 또한, **데드락**이 발생할 수 있습니다.
<br><br/>

6. 트랜잭션에 의해 발생할 수 있는 [데드락](#3-deadlock-교착상태)에 대해 설명
- ***여러 트랜잭션이 실행되지 못하고 서로 무한정 대기 중인 상태***를 의미합니다.
- 예를 들어, 두 개의 트랜잭션 T1, T2가 있다고 가정하겠습니다. 예를 들어, T1은 A를 로킹하고 B의 로킹 해제를 기다려야 하고, T2는 B를 로킹하고 A의 로킹 해제를 기다려야하는 상태입니다.
- 이 때, 두 트랜잭션이 무한정 대기해야 하는 상황이 발생하는데 이를 데드락이라고 합니다.
<br><br/>

7. (6-1) [데드락을 방지할 수 있는 방법은?](#2-deadlock-방지-방법)
- 트랜잭션 시작 전, 필요한 데이터에 모두 LOCK을 걸어 데드락을 방지할 수 있습니다.
- 또 다른 방법으로는, 타임스탬프 기법이 있습니다. 트랜잭션의 식별자로 타임스탬프를 지정하여 순서를 미리 선택하여 데드락을 방지할 수 있습니다.
<br><br/>

8. [트랜잭션 격리 수준의 각 레벨에 대해 간략하게 설명](#4-transaction-isolation-levels)
- 레벨 0부터 3까지 총 4단계의 레벨이 있습니다.
- 레벨 0은 트랜잭션에서 처리중이거나 commit 안된 내용을 다른 트랜잭션이 읽을 수 있는 레벨입니다.
- 레벨 1은 트랜잭션이 수행되는 동안 다른 트랜잭션이 접근할 수 없는 레벨입니다.
- 레벨 2는 트랜잭션에 진입하기 이전에 commit된 내용만 참조할 수 있는 레벨입니다.
- 레벨 3은 트랜잭션에 진입하면 LOCk을 걸어 다른 트랜잭션이 접근하지 못하게 하는 레벨입니다.
- 레벨이 커질수록 성능이 나빠집니다.

<hr/>

## :nerd_face:	What I study
### 1. Transaction
- 데이터베이스의 상태를 변화시키기 위해 한번에 수행되어야 할 연산들
- 수행 중에 한 작업이라도 실패하면 모든 작업이 DB에 반영되지 않으며, 모두 성공해야 DB에 반영된다고 할 수 있다.
- 트랜잭션은 꼭 필요한  최소의 코드에만 적용하는 것이 좋다. (Deadlock)
- commit: 트랜잭션 연산이 정상적으로 처리되어 트랜잭션이 반영된 상태
- rollback: 트랜잭션 연산이 취소되거나 정상적으로 이루어지지 않을 때, 트랜잭션 연산 이전 상태로 돌아가는 것
#### 1) 트랜잭션의 특성 ACID
- 원자성(Atomicity): 트랜잭션 연산의 결과가 데이터베이스에 모두 반영되거나, 아무것도 반영되지 않아야 한다.
- 일관성(Consistency): 트랜잭션 연산이 정상적으로 완료된 후에도 데이터베이스 상태는 무결성을 유지해야 한다.
- 독립성(Isolation): 트랜잭션 연산의 중간에 다른 트랜잭션이 접근할 수 없다.
- 지속성(Durability): 트랜잭션 연산이 성공한 후에는 시스템이 고장나더라도 커밋된 결과가 계속 유지되어야 한다.
#### 2) 트랜잭션을 병행으로 처리 할 때(동시성 제어)의 문제점
- 동시성 제어: 여러 트랜잭션 간의 문제가 발생하지 않도록 트랜잭션의 실행 순서를 제어하는 기법
- **동시에 하나의 데이터가 갱신될 때 또다른 하나의 갱신이 누락**되는 문제
- 하나의 **데이터 갱신이 끝나지 않은 시점에서 다른 트랜잭션이 해당 데이터를 조회**하는 문제
- 두 트랜잭션이 **동시에 실행될 때, 데이터베이스가 일관성이 없는 모순된 상태**로 남는 문제
- 두 트랜잭션이 하나의 레코드를 갱신할 때, **하나의 트랜잭션이 롤백하면 다른 하나의 트랜잭션 마저 롤백**이 되는 문제
- 위와 같은 문제들은 [로킹 제어 기법](#2-locking-제어-기법)을 사용하여 방지할 수 있다.
<br><br/>

### 2. Locking 제어 기법
- 어떤 트랜잭션이 특정 DB의 **데이터를 사용할 때, DB의 일정부분을 LOCK**시키고 .. 트랜잭션이 **완료될 때, 해당부분을 UNLOCK**시키는 방법
- 하나의 트랜잭션이 데이터에 대해 LOCK을 설정하면, 이를 UNLOCK할 때까지 데이터를 독점적으로 사용할 수 있다.
- 즉, 다른 트랜잭션이 LOCK이 걸린 데이터 항목에 대해 동시에 접근하지 못하도록 한다. ***상호배제(Mutual Exclusive)*** <br><br>
#### 1) 로킹 제어 기법의 종류
||공유 Locking|배타 Locking|
|:-----:|:-------:|:-------:|
| Lock 부분 읽기 권한 | O | X |
| Lock 부분 쓰기 권한 | O | O |

<br>

#### 2) 로킹 단위의 차이
|단위가 작을 때|단위가 클 때|
|:-------:|:-------:|
|관리가 어렵다|관리가 쉽다|
|오버헤드가 증가한다||
|병행성이 높다|병행성이 낮다|

<br>

#### 3) 로킹 제어 기법을 사용할 때, 발생할 수 있는 문제점
- 데이터가 많은 경우, **데드락** 발생의 위험성이 있다.
- 로킹 단위가 너무 크면, **트랜잭션의 직렬화 가능성**이 높아진다.
<br><br/>

### 3. Deadlock (교착상태)
- 가정
  - 트랜잭션: T1, T2 / 자원(데이터): A, B
  - T1 : write(A) read(B)
  - T2 : wrtie(B) read(A)
- 이 때, **두 트랜잭션이 무한정 대기해야하는 상황이 발생**하는데 이것을 데드락이라고 한다.
<br>

#### 1) Deadlock 발생 시, 해결 방법
- T1, T2 중 하나를 rollback하고 나머지 하나를 완료시킨다.
- 이후 rollback한 트랜잭션을 다시 실행시킨다.

#### 2) Deadlock 방지 방법
- 데드락 탐지
  - **매번 데드락인지 아닌지 검사**하는 방법
  - 코스트가 크다.
- 데드락 예방
  - 트랜잭션 시작 전, **필요한 데이터에 모두 LOCK**을 건다.
  - 데이터가 많은 경우 코스트가 크다. 
    - Deadlock 발생 위험성 존재
    - 모든 데이터를 전부 로킹해야 하므로 트랜잭션의 직렬화 가능성 존재
- 데드락 회피
  - 시분할 처리를 하여 **T1이 끝나면 T2가 실행되게 한다**.
  - write보다 read가 훨씬 많은 경우, read용 DB를 slave로 두고 로드를 모두 몰아주고 write를 master로 보내고 DB를 동기화 할 수도 있다.
- 타임스탬프 기법
  - 트랜잭션의 식별자로 타임스탬프를 지정하며 **순서를 미리 선택한다**.
  - 트랜잭션이 대기하지 않고 바로 실행한다.
  - **높은 확률로 rollback이 일어나며, 연쇄 복귀를 초래할 수 있다**.
<br><br/>

### 4. Transaction Isolation Levels
- 트랜잭션에서 일관성 없는 데이터를 허용하도록 하는 수준
#### 1) 필요성
- 다른 트랜잭션이 LOCK이 걸린 데이터 항목에 대해 동시에 접근하지 못하도록 한다. ***상호배제(Mutual Exclusive)***
- 하지만, <br> 1) 독립성을 유지하기 위해 **동시에 수행되는 트랜잭션들을 순서대로 처리하게 되면 성능이 떨어진다**. <br>위의 문제를 해결하기 위해, 2) **locking의 범위를 줄인다면 잘못된 값이 처리될 문제**가 발생할 수 있다.
- 그러므로, 효율적인 방법이 필요하게 되었다!
#### 2) 종류
- READ UNCOMMITTED(level 0)
  - 트랜잭션에서 처리중이거나 commit 안된 내용을 다른 트랜잭션이 읽을 수 있다.
  - 데이터베이스의 일관성을 유지하는 것이 불가능하다.
- READ COMMITTED(level 1)
  - SQL 서버가 default로 사용
  - 트랜잭션이 수행되는 동안 다른 트랜잭션이 접근할 수 없다.
  - 커밋이 이루어진 트랜잭션만 조회 가능하다.
- REPEATABLE READ(level 2)
  - 트랜잭션에 진입하기 이전에 commit된 내용만 참조할 수 있다.
  - 다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정이 불가능하다.
  - 트랜잭션이 범위 내에서 조회한 데이터 내용이 항상 동일함을 보장한다.
- SERIALIZABLE(level 3)
  - 트랜잭션에 진입하면 LOCK을 걸어 다른 트랜잭션이 접근하지 못하게 한다.
  - 다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정, 입력이 불가능하다.
  - 성능이 매우 떨어진다.