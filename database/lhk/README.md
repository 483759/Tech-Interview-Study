# 목차
- [인덱스](#인덱스)
- [관계형 DB vs 비관계형 DB](#관계형-데이터베이스와-비관계형-데이터베이스)
- [트랜잭션](#트랜잭션)
- [데이터 모델링](#데이터-모델링)
- [정규화](#정규화)

---

### 인덱스
    - 컬럼의 값과 레코드가 저장된 주소를 키와 값의 쌍으로 만든 것
    - 항상 정렬된 상태를 유지
    - 탐색은 빠르지만, 데이터를 삽입하거나 삭제하는 경우는 비효율적

### 인덱스를 사용하는 이유
    모든 데이터를 확인해서 결과를 가져오기에는 너무 오래걸리기 때문

### DB 인덱스에 해쉬 보다 B Tree를 쓰는 이유는 무엇인가요?
    WHERE 절에서 부등호를 사용할 수 있는데, 해쉬는 이러한 연산에서 문제가 발생하기 때문

---

### 관계형 데이터베이스와 비관계형 데이터베이스
    관계형 데이터베이스는 테이블간의 관계를 맺어 데이터를 조회할 수 있지만, 비관계형 데이터베이스는 테이블간의 관계를 맺을 수 없다.

### RDBMS과 비교하였을 때 NoSQL의 장점
    - RDBMS는 테이블의 스키마가 고정되어있지만, NoSQL은 스키마를 정의하지 않거나 중간에 스키마를 수정할 수 있다.
    - RDBMS가 지원하는 Scale-up뿐만이 아닌, Scale-out이 가능하다.

# NoSQL이 적합한 상황
    1. 처음부터 데이터의 구조를 알 수 없는 상황
    2. 데이터 중복이 가능하므로, update 연산이 자주 발생하지 않는 상황
    3. 대용량 데이터

---

### 트랜잭션
    데이터베이스의 상태를 변화시키는 작업

### 트랜잭션의 성질 ACID
    - Atomicity(원자성) : 트랜잭션이 데이터베이스에 모두 반영되거나 모두 반영되지 않아아 한다.
    - Consistency(일관성) : 트랜잭션의 처리 결과는 항상 일관성이 있어야 한다.
    - Isolation(독립성) : 둘 이상의 트랜잭션이 동시에 실행되면, 서로의 작업을 방해하면 안된다.
    - Durability(지속성) : 트랜잭션이 성공적으로 완료되면, 결과는 영구적으로 반영되어야 한다.

### 트랜잭션을 병행으로 처리할 때 발생할 수 있는 문제점과 이를 방지하기 위한 방법
    - 문제점: 일관성이 깨질 수 있다.
    - 방지: 트랜잭션 간의 상호 작용을 제어하는 기법 사용

## Locking 제어 기법을 사용할 때 Locking 단위를 크게/작게 했을 때의 차이점
    - 크게 했을 때: Lock이 적어져서 관리가 쉽지만, 공유성 수준이 낮아짐
    - 작게 했을 때: Lock이 많아져서 관리가 어렵지만, 공유성 수준이 높아짐

### Locking 제어가 일으킬 수 있는 문제점
    1. 갱신 분실: 2개 이상의 트랜잭션이 같은 자원을 공유하고 접근해서 갱신 시 일부가 사라짐
    2. 모순성: 2개 이상의 트랜잭션이 동시에 같은 곳을 접근해서 결과가 상호 일치하지 않는 일관성 문제
    3. 연쇄 복귀: Rollback했는데, 다른 트랜잭션도 Rollback해서 원하지 않는 결과 발생

### 트랜잭션에 의해 발생할 수 있는 데드락
    두 개이상의 트랜잭션에서 서로의 트랜잭션이 가진 자원을 요구한 채 기다리면 아무런 변화가 없는 것

### 데드락을 방지할 수 있는 방법
    - 트랜잭션을 자주 커밋한다.
    - 정해진 순서대로 자원을 얻는다.

### 트랜잭션 격리 수준의 각 레벨에 대해 간략하게 설명
**1. Read Uncommitted (Level 0)**

    - 트랜잭션이 처리 중이거나, 아직 committed 되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용
    - 데이터 일관성 유지 불가능

**2. Read Committed (Level 1)**

    - 트랜잭션이 수행되는 동안, 다른 트랜잭션은 대기
    - committed된 트랜잭션만 조회 가능
    
**3. Repeatable Read (Level 2)**
    
    - 트랜잭션이 범위 내에서 조회한 데이터 내용은 항상 동일
    - 다른 사용자는 트랜잭션 영역에 해당하는 데이터는 수정 불가능
    
**4. Serializable (Level 3)**

    - 완벽한 읽기 일관성 모드
    - 다른 사용자는 트랜잭션 영역에 해당하는 데이터 수정 및 입력 불가능
    
---

### 데이터 모델링
다양한 데이터 모델에 대해서 설명해주세요.
데이터 모델링의 디자인 스키마에 대해서 설명해주세요.
위에서 답변한 스키마 중에서 어떤 것이 더 낫습니까?

---

### 정규화
- **이상 현상을 제거**하면서 릴레이션을 분해하는 과정
- **함수적 종속성을 판단**하면서 정규화 수행

### 꼭 알아두어야 할 것!
1. [이상 현상](#이상-현상)
2. [함수적 종속성](#함수적-종속성)
3. [정규형](#정규형)
4. [반정규화](#반정규화)
#### 참고 자료 
- KOCW 데이터베이스의 원리와 응용, 백현미 교수님
- https://mangkyu.tistory.com/28

---

### 이상 현상
- 불필요한 데이터 중복으로 릴레이션에 대한 삽입, 수정, 삭제 연산시 발생하는 부작용

### 이상 현상 종류
1. 삽입 이상 - 데이터를 삽입하기 위해 **불필요한 데이터도 함께 삽입**해야 하는 문제

|아이디|주문제품|이름|등급|
|------|-------|---|----|

=> 아직 주문한게 없으면 데이터가 들어갈 수 없음! 임시의 주문번호를 넣어줘야 데이터 삽입 가능

2. 갱신 이상 - 중복 투플 중 **일부만 변경**하여 **데이터가 불일치**하게 되는 모순 문제

|아이디|주문제품|이름|등급|
|------|-------|---|----|
|A-101|아이패드|홍길동|vip|
|A-101|갤럭시탭|홍길동|gold|

=> 아이디가 A-101인 홍길동이 등급이 vip인지 gold인지 모순!

3. 삭제 이상 - 투플을 삭제하면 **꼭 필요한 데이터까지 삭제되는** 데이터 손실 문제

|아이디|주문제품|이름|등급|
|------|-------|---|----|
|A-101|아이패드|홍길동|vip|

=> 홍길동이 O-123 주문을 취소했을 때, 해당 투플을 날려버리면 홍길동 회원 자체가 날라감!

---

### 함수적 종속성
- 속성들 간의 관련성
- X -> Y (X: 결정자, Y: 종속자)
    1. X가 Y를 함수적으로 결정한다.
    2. Y가 X에 함수적으로 종속되어 있다.
- 릴레이션 내의 모든 투플을 대상으로 **하나의 X값에 대한 Y값은 항상 하나**
- 예시

|아이디|주문제품|이름|등급|
|------|-------|---|----|
|A-101|아이패드|홍길동|gold|
|A-999|갤럭시탭|홍길동|silver|
|A-444|아이패드|김이박|gold|

아이디 -> 이름

아이디 -> 등급

이름 -> 등급 (틀림, 이유: 동명이인 홍길동은 등급을 gold, silver 둘 다 가짐)

- 현재 값이 아닌 **속성 자체의 의미로 판단**해야 함
- 위의 예시에서 동명이인이 없다고 이름 -> 등급으로 판단하면 안된다. (값으로 동명이인이 들어오면 난리남)
- 일반적으로 기본키, 외래키가 모든 속성의 결정자 (다른 속성 값이 결정자인 경우도 존재)

### 완전 함수 종속
    - 일반적인 함수 종속을 의미
    - 릴레이션에서 속성 집합 Y가 속성 집합 X에 함수적으로 종속되어 있지만, 속성 집합 Y의 전체가 아닌 일부분에는 종속되지 않음
    - 예시) {아이디, 이벤트 회차} -> 당첨여부
    - 아이디, 이벤트 회차 각각으로 당첨여부를 결정할 수는 없음

### 부분 함수 종속
    - 릴레이션에서 속성 집합 Y가 속성 집합 X의 전체가 아닌 일부분에도 함수적으로 종속됨
    - 예시) {아이디, 주문제품} -> 이름
    - 아이디만으로 이름을 결정 가능

### 이행적 함수 종속
    - 릴레이션을 구성하는 세 개의 속성 집합 X, Y, Z에 대해 함수 종속 관계 X->Y, Y->Z가 존재하면 논리적으로 X->Z 성림
    - 예시) 아이디 -> 등급, 등급 -> 할인율
    - 아이디 -> 할인율 성립

---

### 정규형
    - 릴레이션이 정규화된 정도
    - 각 정규형마다 제약조건 존재
    - 차수가 높아질수록 요구되는 제약조건이 많아지고 엄격
    - 차수가 높아질수록 데이터 중복이 감소하여 이상 현상이 발생하지 않는 바람직한 릴레이션이 됨

### 제 1 졍규형
- 릴레이션에 속한 모든 속성의 도메인이 **원자값으로만 구성**
- 이상 현상 발생 이유? => **기본키에 완전 함수 종속되지 못하는 속성 존재** => 제 2정규형으로
- 예시) 기본키는 아이디, 주문제품

|아이디|주문제품|이름|등급|
|------|-------|---|----|
|A-101|아이패드|홍길동|gold|
|A-999|갤럭시탭|홍길동|silver|

=> 등급이 기본키 {아이디, 주문제품}에 완전 함수 종속되지 못함. (등급은 아이디만으로도 결정될 수 있음)

### 제 2정규형
- 릴레이션이 제 1정규형에 속하고, 기본키가 아닌 **모든 속성이 기본키에 완전 함수 종속**
- 예시

![image](https://user-images.githubusercontent.com/46019755/124612038-f6208680-deac-11eb-8493-f3f1663115f8.png)
- 이상 현상 발생 이유? => **이행적 함수 종속이 존재해서** => 제 3정규형으로

### 제 3정규형
- 릴레이션이 제 2정규형에 속하고, 기본키가 아닌 **모든 속성이 기본키에 이행적 함수 종속이 되지 않음**
- 예시

![image](https://user-images.githubusercontent.com/46019755/124612371-3c75e580-dead-11eb-8a45-a2bde10eaebd.png)

### 보이스-코드 정규형(BCNF)
- 후보키가 1개이고, 3NF 만족하면 BCNF도 만족
- **릴레이션에서 함수 종속성 X -> Y가 성립할 때 모든 결정자 X가 후보키여야 함**
- 예시

![image](https://user-images.githubusercontent.com/46019755/124612607-6deeb100-dead-11eb-8214-05a12836dc24.png)

### 반정규화
    - 정규화를 통해 데이터 중복을 줄여나가면 릴레이션 간의 join 연산이 빈번해지게 되는 문제점 발생
    - 시스템 성능 향상을 위해 중복 통합, 분리 등을 수행해가는 데이터 모델링 기법 중 하나

### 반정규화의 대상
    1. 지나친 join이 발생하는 경우
    2. 일정한 범위만 조회하는 경우
    3. 테이블에 대량의 데이터를 
