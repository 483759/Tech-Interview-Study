# Kubernetes

👇 쿠버네티스 공식 블로그

[운영 수준의 컨테이너 오케스트레이션](https://kubernetes.io/ko/)

# Deployment Environment

컨테이너화 된 워크로드와 서비스를 관리하기 위한 오픈소스 플랫폼으로, 이식성과 확장가능성이 뛰어나다. 선언적 구성과 자동화를 용이하게 만들어 준다.

![container_evolution.svg](Kubernetes%206f1cb1afc6504263b9e637904d8198f5/container_evolution.svg)

## Traditional Deployment

애플리케이션을 물리 서버에서 실행 했던 시기

한 물리 서버에서 여러 애플리케이션의 리소스 한계를 정의할 방법이 존재하지 않아 할당 문제가 발생했다.

물리 서버 하나에서 여러 애플리케이션을 실행하면, 리소스 대부분을 차지하는 애플리케이션 인스턴스가 있을 경우 다른 애플리케이션의 실행 성능이 저하된다.

이를 위해 서로 다른 여러개의 물리 서버에서 각각의 애플리케이션을 실행하는 방법이 있지만 물리 서버를 많이 유지하기 위해 많은 비용을 필요로 한다.

## Virtualized Deployment

단일 물리 서버의 CPU에서 여러 가상 시스템(VM)을 실행할 수 있게 한다.

가상화를 사용하면 1️⃣ VM간에 애플리케이션을 격리하고 2️⃣ 애플리케이션의 정보를 다른 애플리케이션에서 자유롭게 액세스할 수 없으므로, 3️⃣ 일정 수준의 보안성을 제공할 수 있다.

물리 서버보다 리소스를 효율적으로 활용할 수 있으면서, 쉽게 애플리케이션을 추가/수정할 수 있다. 하드웨어 비용의 절감으로 인해 확장성이 크게 증가했으며, 일련의 물리 리소스를 폐기 가능한 가상 머신으로 구성된 클러스터로 만들 수 있다.

각 VM은 가상화된 하드웨어 상에서 자체 OS를 포함한 모든 구성 요소를 실행하는 하나의 완전한 머신이다.

## Container Deployment

컨테이너는 VM과 유사하지만 격리 속성을 완화하여 **애플리케이션 간에 운영체제(OS)를 공유**한다.

그러므로 매우 가볍게 동작하며 VM과 마찬가지로 컨테이너는 자체 파일시스템, CPU 점유율, 메모리, 프로세스 공간을 가진다. 기본 인프라와의 종속성이 없기 때문에 클라우드나 OS 배포본에 모두 이식 가능하다.

- VM이미지보다 쉽고 효율적인 컨테이너 이미지 생성
- 지속적 개발, 통합 및 배포
- 개발과 운영의 관심사 분리
- 애플리케이션 간의 리소스 격리
- OS 수준 정보와 메트릭 뿐 아니라 애플리케이션의 헬스 및 시그널 관측 가능

# Kubernetes

[[Kubernetes Service] 클라우드 시장의 대세, 쿠버네티스란 무엇인가?](https://www.youtube.com/watch?v=JNc11rxLtmE)

컨테이너는 애플리케이션을 포장하고 실행하는 방법이다. 

프로덕션 환경에서는 애플리케이션이 실행중인 컨테이너들을 관리하고, 가동 중지 시간을 확인해야 한다. 예를 들어, 하나의 컨테이너가 다운되면 다른 컨테이너를 다시 시작해야 한다. 

쿠버네티스는 **분산 시스템을 탄력적으로 실행하기 위한 프레임 워크**를 제공하여 시스템이 이러한 행위를 처리하도록 도와준다.

애플리케이션의 확장과 장애 조치를 처리하고, 배포 패턴과 같은 서비스 들을 다음과 같이 제공한다.

### 서비스 디스커버리와 로드 밸런싱

DNS 이름을 사용하거나 자체 IP 주소를 사용하여 컨테이너를 노출할 수 있다.

컨테이너에 대한 트래픽이 많으면 쿠버네티스는 **네트워크 트래픽을 로드밸런싱하고 배포**하여 안정적인 배포를 돕는다.

### 스토리지 오케스트레이션

로컬 저장소, 공용 클라우드 공급자와 같이 원하는 저장소 시스템을 자동으로 탑재할 수 있다.

### 자동화된 롤아웃과 롤백

배포된 컨테이너의 원하는 상태를 서술할 수 있으며, 현재 상태를 원하는 상태로 설정한 속도에 따라 변경할 수 있다.

예를 들어 쿠버네티스를 자동화해서 배포용 새 컨테이너를 만들고, 기존 컨테이너를 제거하고, 모든 리소스를 새 컨테이너에 적용할 수 있다.

### 자동화된 빈 패킹(bin packing)

컨테이너화된 작업을 실행하는 데 사용할 수 있는 쿠버네티스 클러스터 노드를 제공한다. 각 컨테이너가 필요로 하는 CPU와 메모리(RAM)를 쿠버네티스에게 지시한다. 쿠버네티스는 컨테이너를 노드에 맞추어 리소스를 잘 사용할 수 있도록 해준다.

### 자동화된 복구(self-healing)

실패한 컨테이너를 다시 시작하고, 컨테이너를 교체하며, 사용자 정의 상태 검사에 응답하지 않는 컨테이너를 죽이고, 서비스 준비가 끝날 때 까지 이를 캡슐화 하여 표시하지 않는다.

### 시크릿과 구성 관리

암호, OAuth 토큰 및 SSH 키와 같은 중요한 정보를 저장하고 관리할 수 있다. 컨테이너 이미지를 재구성하거나 시크릿을 노출하지 않고도 시크릿 및 애플리케이션 구성을 배포하고 업데이트할 수 있다.

## Not Kubernetes

- PaaS(Platform as a Service)가 아니다.
- 지원하는 애플리케이션 유형을 제약하지 않는다.
- 소스 코드를 배포하지 않고, 애플리케이션을 빌드하지 않는다.
- 애플리케이션 레벨 서비스를 제공하지 않는다.
- 단순한 오케스트레이션 시스템이 아니다.
    - 기존의 것의 기술적인 정의는 A→B→C 와 같이 정해진 워크플로우를 수행하는 것이다.
    - 쿠버네티스는 독립적이고 조합 가능한 제어 프로세스들로 구성되어 있다.
    - 중앙화된 제어 없이 **지속적으로 현재 상태를 입력받은 의도한 상태로 나아가도록** 한다.
    

쿠버네티스를 사용하면 쉽게 사용할 수 있고, 강력하고, 견고하고, 회복력을 갖췄으며, 확장하기 용이한 시스템을 구성할 수 있다.

# Kubernetes Component

![Untitled](Kubernetes%206f1cb1afc6504263b9e637904d8198f5/Untitled.png)

쿠버네티스를 배포하면 **클러스터**를 얻는다

클러스터는 컨테이너화 된 애플리케이션을 실행하는 **노드**라고 하는 워커 머신의 집합이며, 모든 클러스터는 최소 한 개의 워커 노드를 가진다.

워커 노드는 애플리케이션의 구성 요소인 파드를 호스트한다.

컨트롤 플레인은 워커 노드와 클러스트 내 파드를 관리한다.

프로덕션 환경에서는 일반적으로 컨트롤 플레인이 여러 컴퓨터에 걸쳐 실행되고, 클러스터는 일반적으로 여러 노드를 실행하므로 내결함성과 고가용성이 제공된다.

- 노드: 쿠버네티스의 작업 장비
- 파드: 쿠버네티스에서 실행 중인 컨테이너의 집합
- 컨트롤 플레인: 라이프사이클을 정의, 배포, 관리하기 위한 API와 인터페이스를 노출하는 컨테이너 오케스트레이션 레이어