    참조
    Java의 정석(기초편) 저자- 남궁성  
    https://asfirstalways.tistory.com/158

## JVM(Java Virtual Machine)
자바를 실행하기 위한 가상 기계      
자바로 작성된 애플리케이션은 모두 JVM 위에서 실행되므로 JVM이 필요하다.     

### 일반 애플리케이션

<img src="https://user-images.githubusercontent.com/46019755/130355011-5688bb4e-b22e-46fa-8708-a10d20ee77f4.png" width=20% height=50%>        

OS 위에 애플리케이션이 바로 붙어있어서 OS에 종속적이다. 따라서, 다른 OS에서 실행시키기 위해서는 해당 OS에 맞게 애플리케이션을 변경해야한다.

### Java 애플리케이션

<img src="https://user-images.githubusercontent.com/46019755/130354943-204274c6-b986-4071-be1d-ad53a7fac6ce.png" width=20% height=50%>

OS와 Java 애플리케이션 사이에 JVM이 존재하고 있어서 Java 애플리케이션은 OS에 독립적이다. 다른 OS에서 실행시키더라도 애플리케이션을 변경하지 않아도 된다.
이때, OS에 종속적인 것은 JVM이기때문에, JVM만 OS 맞게 변경해주면된다.

## JVM 구조
- **Class Loader** : JVM내로 클래스파일을 동적으로 로드하고 링크를 통해 Runtime Data Area에 바이트코드를 배치하는 작업 수행
- **Execution** : 클래스 실행
- **Runtime Data Area** : 프로그램 실행을 위해 OS에게 할당받은 메모리 공간


<img src="https://user-images.githubusercontent.com/46019755/130359484-093be3c4-1105-4e02-8890-a792c74cb5b2.png" width=50% height=80%>

- **PC** : 현재 수행중인 JVM 명령 주소를 저장한다. Thread가 어디서 어떤 명령을 실행해야하는지 기록한다. 
- **JVM stack** : 지역변수, 매개변수, 리턴 값 등과 같이 할당 후 메서드를 빠져나가면 바로 소멸되는 특성의 데이터를 저장하기 위한 영역이다.
- **Native Method stack** : 바이트 코드가 아닌 기계어로 작성된 프로그램을 실행시키는 영역이다. 커널이 스택을 잡아 독자적으로 프로그램을 실행시킨다.
- **Heap** : new 연산자로 생성된 객체를 저장하는 가상 메모리 공간이다.
- **Method Area** : 클래스를 메모리 공간에 처음 올릴 때, 초기화되는 대상을 저장하기 위한 메모리 공간이다. 
- **Runtime Constant Pool** : Method Area 내에 있는 별도의 관리 영역이다. 상수 자료형을 저장하여 중복을 막는 역할을 한다.


## Java 프로그램 컴파일 과정
1. `Test.java` 파일을 작성한다.
2. `Test.java(클래스 파일)` 을 `자바 컴파일러($javac Test.java)` 로 컴파일하여 `Test.class(바이트 코드)` 파일을 생성한다. 여기서 바이트 코드는 JVM이 읽을 수 있는 코드 형태를 말한다. 
3. 생성된 바이트 코드인 `Test.class` 를 JVM의 `클래스로더` 에게 전달한다.  
4. `클래스로더` 는 `동적 로딩` 을 통해 필요한 클래스를 로딩해서 JVM의 메모리에 올린다.               
5. `실행엔진` 이 메모리에 올라온 바이트 코드를 실행한다.
    - 인터프리터 : 바이트 코드를 한 줄씩 읽어서 실행하므로 느리다.
    - JIT(Just In Time) : 인터프리터 방식으로 실행하다가 바이트 코드 전체를 컴파일해서 실행한다. 이때, 컴파일한 전체 코드는 캐시에 보관되므로 인터프리터 방식보다 빠르다.



## 쓰레드
프로세스(실행중인 프로그램)의 메모리를 이용해서 실제로 작업을 수행하는 것을 말한다.
프로세스는 최소한 하나의 쓰레드를 가지고 있고 (`싱글쓰레드`), 둘 이상을 가지고 있으면 `멀티쓰레드` 라고 한다.

쓰레드는 생성했다고 해서 실행되는 것이 아니라, `start()` 메서드를 호출해야 실행된다.
한 번 종료된 쓰레드는 다시 실행시킬 수 없다. 즉, `start()` 메서드는 딱 한 번만 호출될 수 있다는 의미이다.
쓰레드의 `start()` 를 호출하면, 쓰레드가 독립적인 작업을 수행할 수 있도록 호출스택을 생성하고
생성된 호출스택에 `run()` 이 호출되어 독립적인 공간에서 쓰레드가 작업을 수행한다.

<img src="https://user-images.githubusercontent.com/46019755/130358132-26a1d508-ba87-4847-b8c9-a8c3f591cb8b.png" width=90% height=100%>


## 싱글쓰레드
쓰레드를 한 개 가지고 있는 프로세스를 말한다.  

### 효율적인 경우
- 싱글 코어에서 단순한 계산작업

## 멀티쓰레드
쓰레드를 두 개 이상 가지고 있는 프로세스를 말한다. 
우리가 파일을 다운로드 받으면서 웹 브라우저를 이용할 수 있는 경우를 예로 들 수 있다.                 
하나의 프로세스 내에서 여러 쓰레드가 자원을 공유하는 형태이므로 `동기화` 와 `교착상태` 의 문제가 발생할 수 있다.      

멀티쓰레드가 CPU나 메모리 사용 측면에서는 더 좋지만, 싱글쓰레드보다 작업 시간은 오래걸린다.
그 이유는 쓰레드 간 문맥교환에 따른 시간이 걸리기 때문이다. 
Java 애플리케이션은 OS 사이에 JVM이 있어 OS에 독립적이라고 하지만, 실제로는 JVM 쓰레드 스케줄러에 따라 쓰레드의 실행순서와 실행시간이 영향을 받는다. 

### 효율적인 경우
- 서로 다른 쓰레드가 서로 다른 자원을 사용하는 경우 (입출력 작업)


## 쓰레드 구현 방법
Java에서 쓰레드를 구현하기 위해서는 다음의 두 가지 방법이 있다.
1. Thread 클래스 상속
    ```Java
    class ExThread extends Thread {
      public void run() {
        // Thread 클래스의 run() 오버라이딩해서 기능 구현
      }
    }
    ```
    
    Thread를 상속받은 ExThread 클래스의 인스턴스를 생성한다.
    
    ```Java
    ExThread t = new ExThread();
    ```
    
    
    
2. Runnable 인터페이스 구현 - 일반적으로 Java에서는 다중 상속이 불가능하기 때문에 인터페이스 구현 방법을 주로 사용한다.
    ```Java
    class ExThread implements Runnable {
      public void run() {
        // Runnable 인터페이스의 run() 오버라이딩해서 기능 구현
      }
    }
    ```
    
    Runnable 인터페이스를 구현한 ExThread 클래스의 인스턴스를 생성한 후, Thread 클래스의 생성자 매개변수에 넘겨주어야한다.
    ```Java
    // 인스턴스 생성 방법 1.
    Runnable r = new ExThread();
    Thread t = new Thread(r);
    
    // 인스턴스 생성 방법 2.
    Thread t = new Thread(new ExThread())
    
    ```


## 쓰레드 상태
- `NEW` : 쓰레드가 생성되고 start()가 호출되지 않은 상태
- `RUNNABLE` : 실행 중이거나 실행 가능한 상태
- `BLOCKED` : 동기화블럭에 의해 일시정지된 상태
- `WAITING` , `TIMED_WAITING` : 작업이 종료되지 않았지만, 실행가능하지 않은 일시정지 상태
- `TERMINATED` : 작업 종료되어 소멸된 상태


## 쓰레드 동기화
멀티쓰레드의 경우 서로 다른 쓰레드들이 같은 자원을 공유해서 작업하기 때문에 서로에게 영향을 끼친다.
이러한 것을 방지하기 위해 한 쓰레드가 진행중인 작업을 다른 쓰레드가 방해하지 못하도록 `임계 영역` 과 `잠금(lock)` 을 이용한다.

공유 데이터를 사용하는 코드 영역을 `synchronized` 블럭을 이용해 임계 영역으로 지정하고 공유 데이터가 가지고 있는 lock을 획득한 쓰레드 하나만 이 영역의 코드를 실행할 수 있다.
이 쓰레드는 자신의 작업을 다 하고 코드를 나갈 때 lock을 반납하여 다른 쓰레드가 lock을 획득할 수 있도록 한다.        







