# :question: JAVA

#### reference
https://parkadd.tistory.com/20<br>
https://hoonmaro.tistory.com/19<br>
https://velog.io/@woo00oo/%EC%9E%90%EB%B0%94-%EC%BB%B4%ED%8C%8C%EC%9D%BC-%EA%B3%BC%EC%A0%95
<hr>

## Question
1. [Java의 구동원리(컴파일 과정)를 설명해주세요.]()
- 자바의 구동원리는 어떤 OS에서도 실행할 수 있도록 컴파일 방식과 인터프리터 방식을 같이 쓰는 방식으로 구동이 이루어 집니다. 자바 코드의 경우 컴파일시 class 파일로 컴파일이 이루어집니다. 이후 JVM을 이용하여 구동이 이루어지게 됩니다. 위와 같은 구동원리는 자바의 특징인 한번의 작성으로 모든 플랫폼에서 구동을 이루어지게 하기 위함입니다.
<br><br>

2. [쓰레드란 무엇이고, 싱글쓰레드와 멀티쓰레드의 차이를 설명해주세요.]()
<br><br>

3. [클래스는 무엇이고, 객체는 무엇인지 설명해주세요.]()
<br><br>

4. [인터페이스와 추상클래스의 차이점은 무엇인지 설명해주세요.]()
<br><br>

5. [직렬화가 무엇인지 설명하세요.]()
<hr/>

## :nerd_face:	What I study
### 1. JVM(Java Virtual Machine)
- 자바를 실행하기 위한 소프트웨어로 구현한 가상 컴퓨터
- Java 어플리케이션과 OS 사이에 중개자 역할로 위치한다.
- JVM이 .java의 바이트 코드를 해당 운영체제가 이해할 수 있는 기계어로 변환하여 전달한다.
- 스택 기반으로 이루어져 있다.
- JVM은 OS에 독립적이며, 재사용이 가능하다.
  - JVM을 OS에 맞게 바꿔주면 재사용이 가능하다. (JVM은 주요 OS별로 존재한다.)
  - Java 어플리케이션은 OS가 아닌 JVM과 통신하고, JVM은 Java 어플리케이션으로부터 전달받은 명령을 해당 OS가 이해할 수 있는 기계어로 변환하여 전달한다.
- ***Garbage Collection*** (***자동 메모리 관리***) 을 수행한다.

### 2. JVM 구조
![JVM](https://t1.daumcdn.net/cfile/tistory/2540294C5654207F26)
- Garbage Collector
  - Heap 영역에 생성된 객체들 중에서 참조되지 않은 객체들을 탐색한다. 
  - 이후, 더 이상 사용되지 않는(참조되지 않는) 객체를 제거(해제)하는 방식으로 메모리를 자동 관리한다.
  - GC가 수행하는 시간이 언제인지 정확히 알 수 없다.
- Class Loader
  - JVM 내로 클래스 파일을 로드하고, 링크를 통해 배치하는 작업을 수행하는 모듈이다.
  - 런타임 시에 동적으로 클래스를 로드한다.
- Execution Engine
  - Class Loader를 통해 JVM 내의 Runtime Data Area에 위치한 바이트 코드를 실행한다.
  - Java 바이트 코드를 명령어 단위로 읽어서 실행한다.
- Runtime Data Areas
  - JVM이 OS 위에서 실행되면서 할당받는 메모리 영역이다. 
  - 자바 어플리케이션을 실행할 때 사용되는 데이터들을 적재한다.
  - Class Loader에서 준비한 데이터들을 보관하는 저장소이다.

![memory](https://t1.daumcdn.net/cfile/tistory/216AE04C5654207F0A)
- Method Area
  - 클래스 변수 이름, 타입, 접근 제어자 등과 같은 클래스와 관련된 정보를 저장한다.
  - static 변수, 인터페이스 등을 저장한다.
- Heap Area
  - new를 통해 생성된 객체와 배열의 인스턴스를 저장한다.
  - Garbage Collector는 Heap 영역을 청소하며 메모리를 확보한다.
- Stack Area
  - 메소드가 실행되면 Stack영역에 메소드에 대한 영역이 1개 생긴다.
  - 이 영역에 지역변수, 매개변수, 리턴값 등이 저장된다.
- PC register
  - 현재 쓰레드가 실행되는 부분의 주소와 명령을 저장한다.
  - 쓰레드가 시작될 때 생성되며, 쓰레드마다 하나씩 존재한다.
  - CPU의 레지스터와 다르다.
- Native Method Stack
  - JAVA 외의 언어로 작성된 코드를 위한 메모리 영역이다.

### 3. Java의 구동원리(컴파일 과정)
1. Java의 어플리케이션이 실행되면 JVM은 OS로부터 이 어플리케이션이 필요로 하는 메모리를 요청하여 할당받는다. JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.
2. 자바 컴파일러가(javac) 자바 소스코드를(.java) 읽어들여 바이트 코드(.class) 로 변환시킨다. 
  - 바이트 코드는 아직 컴퓨터가 이해할 수 없는 상태이다. 단순히 자바 가상 머신이 이해할 수 있는 상태이다.
3. Class Loader를 통해 class 파일(컴파일된 바이트 코드) 을 JVM 내부(Runtime Data Area)로 로딩한다.
4. 로딩된 class 파일들은 실행 엔진(Execute Engine)을 통해 명령어 단위로 하나씩 가져와 기계어로 해석된다.
  - 기계어는 컴퓨터가 알아들을 수 있는 언어이다.
  - 실행 엔진은 2가지 방식으로 기계어로 변경한다.
5. 해석된 바이트 코드는 메모리 상(Runtime Data Area)에 배치되어 실질적인 수행을 한다.
6. 이런 실행과정 중에 JVM은 Thread Synchronization 이나 GC(Garbage Collection) 같은 작업을 수행한다.

#### 1) 기계어로 해석하는 방식
- 인터프리터
  - 바이트 코드 명령어를 하나씩 읽어서 해석하고 실행한다.
  - 하나하나의 실행은 빠르나, 전체적인 실행 속도가 느리다는 단점이 있다.
- JIT 컴파일러(Just-In-Time Compiler)
  - 인터프리터의 단점을 보완하기 위해 도입된 방식
  - 바이트 코드 전체를 컴파일하여 바이너리 코드로 변경하고, 이후에는 해당 메서드를 더 이상 인터프리팅하지 않고 바이너리 코드로 직접 실행한다.
  - 하나씩 인터프리팅하여 실행하는 것이 아니라, 바이트 코드 전체가 컴파일된 바이너리 코드를 실행하는 것이기 때문에 전체적인 실행속도는 인터프리터보다 빠르다.
