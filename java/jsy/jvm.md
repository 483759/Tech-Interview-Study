# :question: JVM

#### reference
https://parkadd.tistory.com/20<br>
https://hoonmaro.tistory.com/19<br>
https://velog.io/@woo00oo/%EC%9E%90%EB%B0%94-%EC%BB%B4%ED%8C%8C%EC%9D%BC-%EA%B3%BC%EC%A0%95<br>
https://github.com/HyeminNoh/Tech-Stack/blob/master/docs/Java/GarbageCollection.md
<hr>

## Question
1. [Java의 구동원리(컴파일 과정)를 설명해주세요.](#3-java의-구동원리컴파일-과정)
- 자바의 구동원리는 어떤 OS에서도 실행할 수 있도록 컴파일 방식과 인터프리터 방식을 같이 쓰는 방식으로 구동이 이루어 집니다. 자바 코드의 경우 컴파일시 class 파일로 컴파일이 이루어집니다. 이후 JVM을 이용하여 구동이 이루어지게 됩니다. 위와 같은 구동원리는 자바의 특징인 한번의 작성으로 모든 플랫폼에서 구동을 이루어지게 하기 위함입니다.
```
1. 개발자가 .java 소스코드를 작성합니다.
2. 자바 컴파일러가 소스 코드를 컴파일해서 바이트 코드 .class 파일로 변환합니다.
3. .class 파일을 JVM의 Class Loader에 전달합니다.
4. Class Loader는 동적 로딩을 통해 필요한 클래스들을 JVM 메모리에 올립니다.
5. Execution Engine은 JVM 메모리에 올라온 바이트 코드를 명령어 단위로 하나씩 실행하여 기계어를 해석합니다.
```
<br><br>

2. [Java의 Garbage Collection 동작 과정을 설명해주세요.](#2-gc-동작-과정)
- GC란 JVM 메모리 영역의 Heap 영역을 탐색하여 더이상 참조되지 않는 객체들(Garbage)을 찾아 메모리를 해제하여 메모리를 자동으로 정리해주는 것을 의미합니다.
```
1. 객체를 최초 생성하면, 새로운 객체가 Young 영역의 Eden 영역에 생성됩니다.
2. Eden 영역에 Minor GC가 동작하고, 그 중에서 아직 참조 중인 객체가 Survivor0 로 이동합니다. 
3. 2번의 동작이 반복되어 Survivor0 의 영역이 꽉 차게 되면, Survivor0 영역에 Minor GC가 동작하고, 아직 참조 중인 객체들은 Survivor1 으로 이동합니다.
4. 3의 과정을 끝내고 Survivor0 영역을 다 비웁니다. 1-3 단계들이 반복되어 특정 횟수만큼 살아남은 객체는 Old 영역으로 이동합니다.
5. Old 영역이 가득차서 Survivor 영역에서 Old 영역으로 이동이 불가능할 때, Old 영역에 대한 Major GC가 실행됩니다.
```
<hr>

## :nerd_face:	What I study
### 1. JVM(Java Virtual Machine)
- 자바를 실행하기 위한 소프트웨어로 구현한 가상 컴퓨터
- Java 어플리케이션과 OS 사이에 중개자 역할로 위치한다.
- JVM이 .java의 바이트 코드를 해당 운영체제가 이해할 수 있는 기계어로 변환하여 전달한다.
- 스택 기반으로 이루어져 있다.
- JVM은 OS에 독립적이며, 재사용이 가능하다.
  - JVM을 OS에 맞게 바꿔주면 재사용이 가능하다. (JVM은 주요 OS별로 존재한다.)
  - Java 어플리케이션은 OS가 아닌 JVM과 통신하고, JVM은 Java 어플리케이션으로부터 전달받은 명령을 해당 OS가 이해할 수 있는 기계어로 변환하여 전달한다.
- ***Garbage Collection*** (***자동 메모리 관리***) 을 수행한다.
<br><br>

### 2. JVM 구조
![JVM](https://t1.daumcdn.net/cfile/tistory/2540294C5654207F26)
- Garbage Collector
  - Heap 영역에 생성된 객체들 중에서 참조되지 않은 객체들을 탐색한다. 
  - 이후, 더 이상 사용되지 않는(참조되지 않는) 객체를 제거(해제)하는 방식으로 메모리를 자동 관리한다.
  - GC가 수행하는 시간이 언제인지 정확히 알 수 없다.
- Class Loader
  - JVM 내로 클래스 파일을 로드하고, 링크를 통해 배치하는 작업을 수행하는 모듈이다.
  - 런타임 시에 동적으로 클래스를 로드한다.
- Execution Engine
  - Class Loader를 통해 JVM 내의 Runtime Data Area에 위치한 바이트 코드를 실행한다.
  - Java 바이트 코드를 명령어 단위로 읽어서 실행한다.
- Runtime Data Areas
  - JVM이 OS 위에서 실행되면서 할당받는 메모리 영역이다. 
  - 자바 어플리케이션을 실행할 때 사용되는 데이터들을 적재한다.
  - Class Loader에서 준비한 데이터들을 보관하는 저장소이다.
<br><br>

![memory](https://t1.daumcdn.net/cfile/tistory/216AE04C5654207F0A)
- Method Area
  - 클래스 변수 이름, 타입, 접근 제어자 등과 같은 클래스와 관련된 정보를 저장한다.
  - static 변수, 인터페이스 등을 저장한다.
- Heap Area
  - new를 통해 생성된 객체와 배열의 인스턴스를 저장한다.
  - Garbage Collector는 Heap 영역을 청소하며 메모리를 확보한다.
- Stack Area
  - 메소드가 실행되면 Stack영역에 메소드에 대한 영역이 1개 생긴다.
  - 이 영역에 지역변수, 매개변수, 리턴값 등이 저장된다.
- PC register
  - 현재 쓰레드가 실행되는 부분의 주소와 명령을 저장한다.
  - 쓰레드가 시작될 때 생성되며, 쓰레드마다 하나씩 존재한다.
  - CPU의 레지스터와 다르다.
- Native Method Stack
  - JAVA 외의 언어로 작성된 코드를 위한 메모리 영역이다.
<br><br>

### 3. Java의 구동원리(컴파일 과정)
1. Java의 어플리케이션이 실행되면 JVM은 OS로부터 이 어플리케이션이 필요로 하는 메모리를 요청하여 할당받는다. JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.
2. 자바 컴파일러가(javac) 자바 소스코드를(.java) 읽어들여 바이트 코드(.class) 로 변환시킨다. 
     - 바이트 코드는 아직 컴퓨터가 이해할 수 없는 상태이다. 단순히 자바 가상 머신이 이해할 수 있는 상태이다.
3. Class Loader를 통해 class 파일(컴파일된 바이트 코드) 을 JVM 내부(Runtime Data Area)로 로딩한다.
4. 로딩된 class 파일들은 실행 엔진(Execute Engine)을 통해 명령어 단위로 하나씩 가져와 기계어로 해석된다.
     - 기계어는 컴퓨터가 알아들을 수 있는 언어이다.
     - 실행 엔진은 2가지 방식으로 기계어로 변경한다.
5. 해석된 바이트 코드는 메모리 상(Runtime Data Area)에 배치되어 실질적인 수행을 한다.
6. 이런 실행과정 중에 JVM은 Thread Synchronization 이나 GC(Garbage Collection) 같은 작업을 수행한다.

#### 3-1) 기계어를 해석하는 방식
- 인터프리터
  - 바이트 코드 명령어를 하나씩 읽어서 해석하고 실행한다.
  - 하나하나의 실행은 빠르나, 전체적인 실행 속도가 느리다는 단점이 있다.
- JIT 컴파일러(Just-In-Time Compiler)
  - 인터프리터의 단점을 보완하기 위해 도입된 방식
  - 바이트 코드 전체를 컴파일하여 바이너리 코드로 변경하고, 이후에는 해당 메서드를 더 이상 인터프리팅하지 않고 바이너리 코드로 직접 실행한다.
  - 하나씩 인터프리팅하여 실행하는 것이 아니라, 바이트 코드 전체가 컴파일된 바이너리 코드를 실행하는 것이기 때문에 전체적인 실행속도는 인터프리터보다 빠르다.
<br><br>

### 4. GC(Garbage Collection)
- Heap Area(동적 할당된 메모리 영역) 중에서 더 이상 사용하지 않는 영역을 탐지하여 자동으로 해지하는 기법
- Java는 개발자가 프로그램 코드로 메모리를 명시적으로 해제하지 않기 때문에, Garbage Collector가 더 이상 필요 없는 객체를 찾아 지우는 작업을 한다.
- ex) 객체가 null인 경우, 부모 객체가 null인 경우 포함하는 자식 객체, 블럭 실행 종료 후 블럭 안에서 생성된 객체

#### 4-1) 장단점
- 자동적으로 사용하지 않는 메모리를 해제하기 때문에 메모리 누수에 걱정이 없다는 장점이 있다.
- 메모리를 해제하는 작업에 비용이 들기 때문에 오버헤드가 발생하는 단점이 있다.
- 메모리를 해제하는 시점이 정확하지 않아 실시간 시스템에 적합하지가 않다.

#### 4-2) Garbage Collector
- 더 이상 참조되지 않는 메모리인 Garbage를 정리해주는 JVM의 실행 엔진의 한 요소이다.
- JVM의 메모리 영역 중 Heap 메모리 영역을 다룬다.
- Garbage Collector는 ```1. 메모리 할당, 2. 사용 중인 메모리 인식, 3. 미사용 메모리 인식 ```하는 역할을 담당한다.
- new와 같은 연산에 의해 새롭게 생성된 객체들 중에서, 더 이상 사용되지 않는(참조되지 않는) 객체를 제거(해제)하는 방식으로 메모리를 자동 관리한다.
- 더이상 사용 가능한 메모리 영역이 없는데 계속 메모리를 할당하려고 하면,```Out Of Memory Error``` 가 발생하여 WAS가 다운될 수도 있다. 
  - 즉, 서버가 요청을 처리 못하고 있는 상태가 된다.
- 하지만, 빈번한 GC의 실행은 시스템에 부담이 될 수 있기 때문에, 인스턴스가 Garbage의 대상이 되었다고 해서 바로 소멸되는 것은 아니다.
- GC 알고리즘을 기반으로 GC 실행 타이밍이 계산된다.

#### 4-3) GC 동작 과정
- 메모리를 정리하는 과정이므로, 일반적으로 메모리의 사용을 중단한 채로 진행되어야 한다.
- JVM은 GC를 실행하기 위해 ```stop-the-world``` 를 먼저 실행한다.
  - ```stop-the-world```: GC를 실행하는 쓰레드를 제외한 모든 쓰레드가 작업을 멈춘다. 그리고 GC가 끝나면 다시 작업을 재개한다.
  - 어떤 GC 알고리즘을 사용하더라도, stop-the-world는 불가피하며 이 과정을 최소화하기 위해 GC 튜닝을 진행한다.
- GC의 작업은 Young 영역에 대한 Minor GC와  Old 영역에 대한 Major GC(Full GC)로 나누어진다.
- GC가 접근하는 메모리 영역은 Young 영역에 포함되는 Eden, Survivor1, Survivor2와 Old 영역이다.
  1. Young 영역
    - 새롭게 생성된 객체들이 위치한다.
    - 대부분의 객체는 참조되었다가 금방 접근 불가능한 상태가 되기 때문에, GC로 인해 많은 객체들이 Young 영역에 생성되었다가 사라진다.
    - 각 하위 영역이 가득 차면 Minor GC가 동작하여 더이상 참조되지 않는 객체를 제거한다.
  2. Old 영역
    - Young 영역에서 계속 사용되어 살아남은 객체가 복사된다.
    - Young 영역보다 크게 할당되며 더 적은 GC가 발생한다.
    - 각 하위 영역이 가득 차면 Major GC가 동작하여 더이상 참조되지 않는 객체를 제거한다.

```
1. 객체를 최초 생성하면, 새로운 객체가 Eden 영역에 생성된다.
2. Eden 영역에 GC(Minor GC)가 동작하고, 그 중에서 아직 참조 중인 객체가 Survivor0 로 이동한다.
3. 2번의 동작이 반복되어 Survivor0 의 영역이 꽉 차게 된다.
4. Survivor0 영역에 GC(Minor GC)가 동작하고, 아직 참조 중인 객체들은 Survivor1 으로 이동한다.
5. 4의 과정을 끝내고 Survivor0 영역을 비운다. (2개의 Survivor 영역 중 1개는 반드시 비어있어야 한다.)
6. 위의 단계들이 반복되어 특정 횟수만큼 살아남은 객체는 Old 영역으로 이동한다. (Survivor0 <-> Survivor1)
7. Old 영역이 가득차서 Survivor 영역에서 Old 영역으로 이동이 불가능할 때, Old 영역에 대한 GC(Major GC)가 실행된다.
```