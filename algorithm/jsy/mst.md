# :question: MST(Minimal Spanning Tree)

#### reference
https://gmlwjd9405.github.io/2018/08/28/algorithm-mst.html<br>
https://onepwnman.github.io/MST/<br>
https://devraphy.tistory.com/83<br>
https://it-earth.tistory.com/98
<hr>

## Question
1. 최소비용 신장트리(MST)가 무엇인지 설명하고, 대표 알고리즘 2개(크루스칼, 프림)를 비교해주세요.
- 최소비용 신장트리는 간선들의 가중치를 고려하여 최소 비용을 갖도록 하는 신장트리입니다. 신장트리는 가장 적은 개수의 간선으로 모든 정점을 연결하는 트리를 뜻합니다.
- 크루스칼은 시작 정점을 정하지 않고 최소 비용의 간선을 순서대로 대입하면서 트리를 구성해나가기 때문에, 사이클 여부를 항상 확인해야합니다. 반면, 프림은 시작 정점을 정하고 해당 정점에서 최소 비용(거리)을 갖는 정점을 선택하면서 트리를 확장시키기 때문에 사이클을 이루지 않으므로, 사이클 여부를 확인하는 과정이 필요하지 않습니다.
- 이러한 점에서 크루스칼은 간선 중심의 알고리즘, 프림은 정점 중심의 알고리즘이라는 차이점을 가지고 있다고 할 수 있습니다.
<hr>

## :nerd_face:	What I study
### 1. Spanning Tree (신장 트리)
![spanning](https://gmlwjd9405.github.io/images/algorithm-mst/spanning-tree.png)
- 그래프 내의 모든 정점을 포함하는 트리
- 그래프의 최소 연결 부분 그래프
  - 가장 적은 개수의 간선으로 모든 정점을 연결할 수 있다.

#### 1-1. 특징
- **모든 정점들이 연결**되어 있어야 한다.
- **사이클이 포함되서는 안된다.**
- 그래프가 `n`개의 정점을 가지고 있다면, 정확히 `n-1` 개의 간선으로 연결한다.
  - n개의 정점을 가지는 그래프의 최소 간선의 수 : `n-1`개
- ex) 통신 네트워크 구축 - 최소의 케이블(링크)을 사용하여 연결하고자 하는 경우

<br>

### 2. MST (Minimal Spanning Tree, 최소 신장 트리)
- Spanning Tree 중 사용된 간선들의 가중치를 고려하여 최소 비용을 갖는 트리
- 가장 적은 개수의 간선과 비용으로, 모든 정점을 연결할 수 있다.
- cf) 절대적이진 않지만, 간선이 적으면 kruskal, 간선이 많으면 prim 이 유리하다.

#### 2-1. 특징
- **모든 정점들이 연결**되어 있어야 한다.
- **사이클이 포함되서는 안된다.**
- 그래프가 `n`개의 정점을 가지고 있다면, 정확히 `n-1` 개의 간선으로 연결한다.
- ***간선의 가중치의 합이 최소여야 한다.***
- ex) 통신망, 도로망, 유통망에서 '길이, 구축 비용, 전송 시간'(이게 가중치를 의미함) 등을 최소로 하여 구축하고자 하는 경우

<br><br>

### 3. Kruskal MST Algorithm
![kruskal](https://onepwnman.github.io/assets/images/mst/kruskal.gif)
- **Greedy하게** 네트워크의 모든 정점을 최소 비용으로 연결하는 최적 해답을 구하는 알고리즘
- **간선 중심**으로 간선 선택을 기반으로 하는 알고리즘
- 이전 단계에서 만들어진 신장 트리와는 상관없이 **무조건 최소 간선만을 선택**한다.
- kruskal 알고리즘은 최적의 해답을 주는 것으로 검증되어 있으므로, 따로 증명하지 않아도 된다.
- cf) greedy ? 그 순간에는 최적이지만, 전체적인 관점에서 최적이라는 보장이 없기 때문에 반드시 검증해야 한다.

#### 3-1. 동작
1. 그래프의 모든 간선들을 리스트로 담아, 가중치의 오름차순으로 정렬한다.
2. 정렬된 간선 리스트에서, 가중치가 가장 작은 간선을 선택한다.
3. 사이클을 형성하지 않는다면, 해당 간선을 현재의 MST의 집합에 추가한다.
4. 위의 과정을 반복한다.

#### 3-2. 구현
- 가중치를 저장하여, Edge 관리를 해야한다.
- union-find 를 사용하여 구현한다.
  - 왜? 현재 선택된 간선이 MST 집합에서 사이클을 이루는 간선인지 확인(**find**) -> 사이클을 형성하지 않는다고 확인되면, MST 집합에 합침(**union**)

#### 3-3. 시간복잡도
![kruskal](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FUxeke%2FbtqJs4y1tXA%2F7HDz2N2NjtSEFNhOKh5Rsk%2Fimg.png)
- 간선이 e개일 때, `O(elog(e))` 의 시간복잡도를 갖는다.
- 간선들을 정렬하는 시간에 영향을 많이 받는다.
- 정점의 개수에 비해 간선의 개수가 적은 경우 유리하다.

1. 모든 정점(n개)을 독립적인 집합으로 만든다. `O(n)`
   - 노드의 개수만큼 parent, rank(depth) 집합을 초기화한다.
   - 전체 시간복잡도에 큰 영향을 미치지 않으므로 삭제 
2. 그래프의 모든 간선을 가중치 기준으로 오름차순 정렬한다 `O(elog(e))`
3. 2개 부분집합 각각의 루트노드를 확인(find)하고, 루트노드가 서로 다른 경우 union한다 `O(1)`
   - union-by-rank 기법과 path compression 기법을 사용하면 상수에 가까운 시간복잡도를 갖는다. 

<br>

### 4. Prim MST Algorithm
![prim](https://onepwnman.github.io/assets/images/mst/prim.gif)
- 시작 정점에서부터 출발하여 신장트리 집합(MST)을 단계적으로 확장해나가는 알고리즘
- **정점 중심**으로 정점 선택을 기반으로 하는 알고리즘
- 이전 단계에서 만들어진 **신장 트리를 확장**해나간다.

#### 4-1. 동작
1. 시작 단계에서는 **시작 정점만이** MST 집합에 포함된다.
2. 앞 단계에서 만들어진 **MST 집합에 인접한 정점들** 중에서 **1)방문한 적이 없으며, 2)가장 낮은 가중치를 갖는 정점을 선택**하여, 트리를 확장한다.
3. 위의 과정을 트리가 `n-1`개의 간선을 가질 때까지 반복한다.

#### 4-2. 구현
- 가중치를 저장하여, Edge 관리를 해야한다.
- priority queue, queue 를 사용하여 구현한다.
  - 왜? priority queue는 MST의 정점과 인접한 간선 중 최소 가중치 간선(**우선순위**)을 먼저 뽑아내기 위해 사용하고, queue는 정점 방문 스케줄링 관리를 위해 사용한다.

#### 4-3. 시간복잡도
#### 4-3-1) 우선순위 큐를 사용하지 않을 때
- 정점이 n개일 때, `O(n^2)` 의 시간복잡도를 갖는다.
- 최소 비용의 정점을 찾는 시간에 영향을 많이 받는다.

1. 모든 정점을 초기화한다. `O(n)` 
   - 전체 시간복잡도에 큰 영향을 미치지 않으므로 삭제 
2. 최악의 경우 시작 정점 집합과 그렇지 않은 집합의 모든 노드를 탐색하게 된다. `O(n^2)`
   - 주 반복문이 정점의 수 n만큼 반복, 내부 반복문이 모든 노드를 또 n만큼 반복하면서 탐색

#### 4-3-2) 우선순위 큐를 사용할 때
- 정점이 n개일 때, `O(elog(n))` 의 시간복잡도를 갖는다.
- 간선의 개수에 비해 정점의 개수가 적은 경우 유리하다.

1. 모든 정점을 초기화한다. `O(n)` 
   - 전체 시간복잡도에 큰 영향을 미치지 않으므로 삭제 
2. 우선순위 큐의 push/pop 연산 `O(log(n))`
3. 모든 간선(e개)을 확인하기 위해, 우선순위 큐에 간선을 push/pop하는 연산 최대 e번 수행 `O(e)`
