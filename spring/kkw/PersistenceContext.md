### Persistence Context (영속성 컨텍스트)

- 엔티티를 영구히 저장하는 환경
- 논리적인 개념
- 엔티티 매니저를 통해서 영속성 컨텍스트에 접근

### 엔티이의 생명주기

- 비영속(new/transient) : 영속성 컨텍스트와 전혀 관계가 없는 상태
  - 순수한 객체 상태
- 영속(managed) : 영속성 컨텍스트에 저장된 상태
  - 영속 상태는 영속성 컨텍스트에 의해 관리된다는 뜻
  - em.find(), JPQL을 사용해서 조회된 엔티티들
- 준영속(detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태
  - 영속성 컨텍스트가 관리하던 영속 상태의 엔티티를 관리하지 않는 상태로 바뀌는 것
  - em.detach(entity), em.close(), em.clear()
- 삭제(removed) : 삭제된 상태
  - 영속성 컨텍스트와 DB에서 삭제한다
  - em.remove(entity)

### 영속성 컨택스트의 특징

- 영속성 컨택스트와 식별자 값
  - 엔티티를 식별자 값(@Id)로 구분한다.
  - 영속 상태는 식별자 값이 반드시 있어야 한다.
- 영속성 컨텍스트와 데이터베이스 저장
  - JPA는 트랜잭션을 커밋하는 순간 영속성 컨택스트에 새로 저장된 엔티티를 DB에 반영한다(Flush)
- 장점
  - 1차 캐시
    - find()를 하게 되면 1차 캐시를 먼저 조회하게 되어, 1차 캐시에 해당 엔티티가 존재하면 바로 반환한다
  - 동일성(identity) 보장
    - 동일성(identity) : 실제 인스턴스가 같아서 참조 값이 같다.
    - 동등성(equality) : 실제 인스턴스는 다르지만, 가지고 있는 값이 같은 경우
  - 트랜잭션을 지원하는 쓰기 지연
  - 변경 감지(Dirty Checking)
    - 변경 감지는 영속 상태의 엔티티에만 적용됨
    - JPA는 엔티티를 영속성 컨텍스트에 보관할 때, 최초 상태를 복사해서 저장해준다(스냅샷)
    - 엔티티와 스냅샷을 비교하여 변경된 엔티티를 찾는다.
    - 변경된 엔티티가 있는 경우 수정 쿼리를 생성하여 쓰기 지연 SQL 저장소에 보낸다.
    - 쓰기 지연 저장소의 SQL을 DB에 보낸다
    - DB에 트랜잭션을 커밋한다
    - JPA는 Update 문을 작성할 시 엔티티의 모든 필드를 업데이트 함(데이터 전송량이 증가하지만 대신에 수정 쿼리가 항상 같음)
      -> @org.hibernate.annotations.DynamicUpdate를 사용하면 수정된 부분만 Update 가능
  - 지연 로딩

### 플러시(Flush)

- 플러시(flush())는 영속성 컨텍스트의 변경 내용을 DB에 반영한다
- 영속성 컨텍스트의 변경 내용을 DB에 동기화하는 것
- 영속성 컨텍스트를 플러시하는 3가지 방법
  - em.flush()를 직접 호출
    - 테스트나 다른 프레임워크와 함께 JPA를 사용할 때를 제외하곤 거의 사용 안 함
  - 트랜잭션 커밋 시 플러시가 자동 호출
    - 트랜잭션을 커밋하기 전에 영속성 컨텍스트의 변경 내용을 DB에 반영해야 하기 때문에, JPA에서 트랜잭션 커밋 전에 자동으로 호출함
  - JPQL 쿼리 실행 시 플러시가 자동 호출
    - JPQL은 SQL로 변환되어 DB에서 엔티티를 조회한다.
    - 영속성 컨텍스트에 존재하는 엔티티들을 JPQL로 조회를 하는 경우, 제대로 된 값을 줄 수가 없다.
    - 그래서 JPA에서는 JPQL을 실행할 때 플러시를 자동으로 호출 해 준다.
