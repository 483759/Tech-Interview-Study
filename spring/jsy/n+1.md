# :question: JPA N+1 문제

#### reference
https://incheol-jung.gitbook.io/docs/q-and-a/spring/n+1<br>
https://www.popit.kr/jpa-n1-%EB%B0%9C%EC%83%9D%EC%9B%90%EC%9D%B8%EA%B3%BC-%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95/<br>
https://velog.io/@woo00oo/N-1-%EB%AC%B8%EC%A0%9C
<hr>

## Question
1. N+1 문제가 발생하는 이유와 이를 해결하는 방법을 설명해주세요.
- N+1 문제는 JPA의 프록시로 인한 지연로딩 때문에 발생합니다. 구체적으로는 1개의 쿼리를 실행했을 때, 내부에 존재하는 연관된 엔티티들을 추가로 조회해오면서 생기는 문제입니다.
- 최고의 해결방법은, 되도록이면 @OneToMany의 매핑을 하지 않을 수 있다면 하지 않는 것입니다. 만약 사용해야한다면, Fetch join이라고 하는 JPQL의 join fetch를 사용합니다. 데이터 호출 시점에 모든 연관 관계의 데이터를 가져오므로, 쿼리 한 번으로 해결이 가능합니다.
<hr>

## :nerd_face:	What I study
### 1. N+1 문제 ?
- 연관 관계에서 발생하는 이슈
- 연관 관계가 설정된 엔티티를 조회할 경우에 조회된 데이터 개수(N)만큼 연관관계의 조회 SQL이 추가로 발생하여 데이터를 읽어온다.
- 즉, 1번 SQL을 실행해서 N번 SQL을 추가로 실행한다고 해서 N+1 문제라 한다.
- ex) SQL 1번으로 100명의 회원을 조회하였는데, 각 회원마다 주문한 상품을 추가로 조회하기 위해 100번의 SQL이 추가로 실행된다.
<br><br>

### 2. N+1 문제 원인
- JPQL은 SQL을 추상화한 객체지향 쿼리 언어이다.
  - 특정 SQL에 종속되지 않고 엔티티 객체와 필드 이름을 가지고 쿼리를 생성한다.

<br>

- JPA Repository에서 정의한 인터페이스 함수를 실행하면, JPA는 함수 이름을 분석해서 JPQL을 생성하여 실행하게 된다.
- 생성한 JPQL을 분석하여 생성한 SQL을 실행하는 동작에서 N+1 문제가 발생한다.

```
1. 즉시로딩을 데이터를 가져오는 경우
- JPQL에서 동작한 쿼리를 통해서 데이터를 조회한다. (1)
- 이후에, 연관된 하위 엔티티에 대해 추가적인 로딩 작업을 진행한다. (N)

2. 지연로딩으로 데이터를 가져온 후에, 가져온 데이터에서 하위 엔티티를 다시 조회하는 경우
- 엔티티 객체와 필드 이름만을 보고 쿼리를 생성하기 때문에, Join으로 쿼리 생성이 안된다. (1)
- 즉, 하위 엔티티를 조회할 때는 지연로딩이라고 할지라도 쿼리를 새로 생성하여 실행해야 한다. (N)
```
<br>

#### cf. 글로벌 패치 전략
- 실무에서는 가급적 지연로딩만을 사용한다.

||즉시로딩(EAGER Loading)|지연로딩(LAZY loading)|
|:---:|:---:|:---:|
||`@xxToxx(fetch = fetchType.EAGER)`|`@xxToxx(fetch = fetchType.LAZY)`|
|데이터 조회 시|연관된 데이터를 모두 조회|필요한 시점에 필요한 연관 데이터만 조회|
|프록시 객체 사용 여부|X|O|
|예시|`@xxToOne`|`@xxToMany`|

<br><br>

### 3. N+1 문제 해결
#### 3-1. Fetch join
- fetch를 통해서 조인 쿼리를 실행하는 방법이다.
- 연관된 엔티티를 조회하기 위해, 미리 쿼리를 통해 테이블을 조인해서 가져온다.
  - 프록시 객체가 아닌 실제 엔티티를 조회한다.
  - 데이터 호출 시점에 모든 연관 관계의 데이터를 가져온다.
- 단점
  - JPA Repository에서 정의한 인터페이스 함수가 아닌, JPQL로 직접 작성해야 한다.
  - 하나의 쿼리문을 통해 가져오므로, JPA에서 제공하는 Pageable 의 사용이 불가능하다.
  - 1:N 관계가 2개인 엔티티는 사용이 불가능하다. (= 2개의 컬렉션은 불가능) <br> (ex. member vs orders = 1:N && member vs coupon = 1 : N 이면, member에 대한 fetch join은 안됨.)
  - 글로벌 패치 전략이 무시된다. (FetchType을 LAZY로 하는 의미가 없다.)

#### 3-2. Batch size 조절
- 설정한 size만큼 데이터를 미리 로딩하는 방법이다.
- 지정된 size만큼 SQL의 `where in`절을 사용하여 조회한다.
- JPA에서 제공하는 Pageable 처럼, 개수가 고정된 데이터를 가져올 때 함께 사용하면 유용하다.
- 단점
  - 글로벌 패치 전략을 즉시 로딩으로 변경해야한다.

#### 3-3. EntityGraph
- 변수 `attributePaths` 값에 쿼리 수행시 바로 가져올 필드명을 지정하면 LAZY가 아닌 EAGER 전략으로 데이터를 가져온다.
- JPQL을 사용하여 쿼리를 작성하고 필요한 연관관계를 EntityGraph에 설정한다.
- Join문이 Outer join으로 실행된다.

#### 3-4. @Fetch(FetchMode.SUBSELECT)
- 두 번의 쿼리로 해결하는 방법이다.
- 해당 엔티티를 조회하는 쿼리는 그대로 발생하고, 연관관계의 하위 엔티티를 조회할 때 서브 쿼리로 함께 조회한다.
- **모두 지연로딩으로 설정하고, 성능 최적화가 필요한 곳에는 JPQL Fetch join을 사용하는 것이 추천되는 전략이다.**

#### 3-5. QueryBuilder
- Query를 실행하도록 지원하는 다양한 플러그인.
- ex. Mybatis, QueryDSL, JDBC Template 등