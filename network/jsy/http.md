# :question: HTTP 프로토콜

#### reference
https://mangkyu.tistory.com/91<br>
https://hongsii.github.io/2017/08/02/what-is-the-difference-get-and-post/<br>
https://brunch.co.kr/@artiveloper/24
<hr>

## Question
1. [HTTP와 HTTPS의 차이에 대해 설명하세요.]()
- HTTP는 서버/클라이언트 모델을 따라 인터넷에서 데이터를 주고 받기 위한 프로토콜입니다. HTTP는 평문 데이터를 전송하기 떄문에, 보안에 취약합니다.
- 이를 해결하기 위해, 민감한 데이터를 암호화하여 암호화된 데이터 통신을 하기 위한 프로토콜로 HTTPS를 사용합니다.
<br><br>

2. [HTTP의 GET 방식과 POST 방식을 비교해주세요.](#2-http-요청-메서드)
- GET은 리소스 조회를 위한 메서드입니다. <br>데이터를 헤더에 추가하여 전송하며, <br>URL 안에 쿼리스트링으로 데이터를 전송하기 때문에, 보안적으로 중요한 데이터를 포함하면 안됩니다.
- POST는 리소스 생성/변경 등의 처리를 위한 메서드입니다. <br>데이터를 body에 추가하여 전송하며, <br>URL에 데이터가 노출되지 않아, 상대적으로 GET보다 안전합니다.
<br><br>

3. [HTTP의 Statue Code의 종류는 어떻게 되나요?](#4-http-status-code)
<br><br>

4. [주소창에 URL을 치고 엔터를 치면 흐름이 어떻게 되나요?](#3-주소창에-url을-치고-엔터를-친-이후의-흐름)
<hr>

## :nerd_face:	What I study
### 1.HTTP 프로토콜 (HyperText Transfer Protocol)
- OSI 7계층 중 응용계층의 프로토콜, TCP/IP 위에서 동작한다.
- 인터넷에서 데이터를 주고 받을 수 있는 프로토콜
- HTML 문서 뿐만 아니라, 다양한 종류의 데이터를 전송할 수 있다.

#### 1) HTTP 특징
- 클라이언트/서버 구조
  - 클라이언트 -> 클라이언트의 요청 -> 서버 -> 서버의 응답 -> 클라이언트
  - 클라이언트의 요청에 대해 응답을 하는 구조 (서버가 먼저 요청 못함)
- 무상태(stateless)
  - 클라이언트와 서버의 연결이 끊어지고 통신이 끝날 때, 상태를 유지하지 않는다.
  - 클라이언트의 이전 상황을 알 수 없다.
  - 이를 대처하기 위해, Cookie와 Session을 사용한다.
- 비연결성(connectionless)
  - '클라이언트 -> 클라이언트의 요청 -> 서버 -> 서버의 응답 -> 클라이언트'<br>이렇게 한 사이클이 끝나면, 바로 연결을 끊는다.
  - 클라이언트/서버 구조에서 최대 연결 수보다 훨씬 많은 요청/응답을 처리할 수 있다.

#### 2) HTTP 요청 메서드
- GET
  - 리소스 조회
  - 필요한 데이터를 body에 담지 않고, 쿼리스트링을 통해 전송
  - 데이터가 노출되어 보안에 취약
  - URL의 길이가 제한되어 있어, 전달할 수 있는 데이터의 양이 많지 않음
- POST
  - 요청 데이터 처리 (리소스 생성/변경)
  - 주로 데이터 등록에 사용됨
  - 필요한 데이터를 [HTTP 메시지](#3-http-메시지) body에 담아서 전송
  - GET보다 보안에 안전할 수 있으나, 크롬 개발자 도구로 데이터를 확인할 수 있음<br>->그러므로, 민감한 정보는 HTTPS 프로토콜을 사용하여 암호화하여 전송해야 함
  - 길이의 제한없이 대용량 데이터 전송 가능, 객체 형식의 데이터도 전송이 가능
  - 데이터 캐시 없음 -> 브라우저 히스토리에도 남지 않음
  - 따라서 뒤로가기, 북마크 불가능
- PUT
  - 리소스 전체 대체
  - 해당 리소스가 없으면 생성
  - 전체를 다 덮어쓴다고 생각하기
- PATCH
  - 리소스 부분 대체
- DELETE
  - 리소스 삭제
  - 일반적으로 RequestBody가 아닌 URI 경로에 제거하려는 리소스를 전달
- HEAD
  - GET과 동일하게 리소스 조회
  - but 메시지 부분을 제외하고, 상태줄과 헤더만 반환
  - ex) 서버에 리소스가 있는지 확인하는 용도, 메타 데이터를 읽으려고 할 때
- OPTIONS
  - 대상 리소스에 대한 통신 수행 가능 옵션(메서드)을 알아보기 위해 사용
  - 주로 CORS에서 사용

#### 3) HTTP 메시지
|3-1. 요청 메시지|
|---|
|![request](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fc7mI3U%2FbtqWX45M76d%2FgGoVLK6rcUJhekrxMcq6a1%2Fimg.png)|
|80번 포트(웹 HTTP 통신 기본 포트)인 경우, 포트 번호가 생략된다.|

|3-2. 응답 메시지|
|---|
|![response](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FCmjnf%2FbtqWTYTN3X1%2F34p8xLsQtEIk0xMzyjIw8k%2Fimg.png)|
|https://developer.mozilla.org/ko/docs/Web/HTTP/Overview , HTTP 메시지|

#### 4) HTTP Status Code
- 1xx : 정보가 수신되어 처리중이다
- 2xx : 클라이언트의 요청을 성공적으로 처리했다.
- 3xx : 요청을 완료하기 위해 추가 조치가 필요하다.
- 4xx : 클라이언트의 요청에 오류가 있다.
- 5xx : 서버 문제로 오류가 있다.
<br><br>

### 2. HTTPS 프로토콜 (HyperText Transfer Protocol Secure)
- HTTP + ***S (Secure)***
- 정보를 암호화하는 [SSL 프로토콜](#1-ssl-secure-socket-layer)을 이용하여 클라이언트와 서버가 데이터를 주고 받는 통신규약
- S? secure socket, 안전한 통신망
  - 브라우저와 웹 사이트 간의 모든 통신이 암호화되어 있다.

#### 1) SSL (Secure Socket Layer)
- 네트워크 내에서 메시지 전송의 안전을 관리하기 위해 만들어진 프로그램 계층
- 대칭키 암호화 방식 / 공개키 암호화 방식을 혼합한 하이브리드 암호 시스템을 사용한다.
  - 공개키 암호화 방식으로 통신에 사용할 대칭키를 교환한 다음, 이후의 통신은 대칭키 암호화 방식을 사용하며 통신한다.
```
1. A가 B의 공개키로 암호화 통신에 사용할 대칭키를 암호화 하여 B에게 보낸다. 
2. B는 암호문을 받아, 자신의 개인키로 복호화 한다. 
3. B는 A로 부터 받은 대칭키로 A에게 보낼 내용을 암호화 하여 보낸다.
4. A는 자신의 대칭키로 암호문을 복호화 한다. 
5. 계속해서 대칭키로 통신한다. 
```
- SSL 인증서: 클라이언트와 서버간의 통신을 제 3자가 보증하는 전자화된 문서, key를 가지고 있어야 암호화/복호화 가능
- 대칭키 암호화 방식
  - 하나의 키로 암호화/복호화를 모두 하는 암호화 방식
  - 서버와 클라이언트가 같은 키를 사용해야 하므로, 키를 공유하는 문제가 있다.
  - 대칭키 전달 과정에서 누군가가 대칭키를 획득하면, 쉽게 암호화된 데이터를 알아낼 수 있다.
- 비대칭키 암호화 방식
  - 두 개의 키(공개키, 개인키)로 암호화/복호화를 하는 암호화 방식
  - 공개키를 통해 암호화된 것은 개인키를 통해 복호화될 수 있고,<br>개인키를 통해 암호화된 것은 공개키를 통해 복호화될 수 있다.
  - A(B)키로 암호화 하면 B(A)키로 복호화 할 수 있어야 한다.
  - ex) 클라이언트에서 공개키/개인키를 생성 -> 생성한 공개키를 서버에 전달 -> 서버 접속 시 클라이언트의 개인키을 사용하여 접속
  - 공개키를 배포함으로써 키 공유 문제는 해결되지만, 처리 속도가 느린 문제가 있다.

#### 2) 왜 모든 페이지에서 HTTPS 프로토콜을 사용하지 않을까?
- 추가 비용이 발생한다. (SSL 인증서 구입 비용 및 갱신 비용)
- 암호화 통신을 하기 때문에, 서버의 성능에 영향을 준다. (리소스가 상대적으로 많이 필요) <br> -> 처리할 수 있는 요청의 수가 상대적으로 적어짐.
- 따라서, 민감한 정보(노출되면 안되는 정보)를 처리할 때만 HTTPS에 의한 암호화 통신을 해야한다.
<br><br>

### 3. 주소창에 URL을 입력하고 엔터를 친 이후의 흐름
![url](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdmomKO%2FbtqK84xb9yy%2FktAElZQp6AFyxgXG35eORk%2Fimg.png)
1. 사용자가 브라우저에 URL을 입력한다.
2. 브라우저는 DNS를 통해 서버의 진짜 주소를 찾는다.
  - URL 중 도메인 네임 부분을 DNS 서버에 검색한 후,
  - DNS 서버에서 해당 도메인 네임에 해당하는 IP 주소를 찾아 URL 정보와 함께 전달한다.
3. IP 주소, URL 정보가 HTTP 프로토콜을 사용하여 HTTP 요청 메세지를 생성한다.
4. HTTP 요청 메시지는 TCP/IP 연결(TCP 통신)을 통해 인터넷을 거쳐 서버로 전송된다.
5. 도착한 HTTP 요청 메시지는 HTTP 프로토콜을 사용하여 웹 페이지 URL 정보로 변환되어, 웹 페이지 URL 정보에 해당하는 데이터를 검색한다.
6. 서버는 HTTP 프로토콜을 사용하여 HTTP 응답 메세지를 생성한다.
7. 검색된 웹 페이지 데이터는 TCP/IP 연결(TCP 통신)을 통해 인터넷을 거쳐 요청한 컴퓨터로 전송된다.
8. 도착한 HTTP 응답 메세지는 HTTP 프로토콜을 사용하여 웹페이지 데이터로 변환된다.
9. 웹페이지 데이터는 웹 브라우저에 의해 출력되어 사용자가 볼 수 있게 된다.