# 메인 메모리

#### logical address : CPU가 생성하는 주소
#### physical address : 메모리가 취급하는 주소(메모리 주소 레지스터에서 주어지는 주소)
- 컴파일(Compile) 타임 바인딩과 적재(Load) 타임 바인딩 기법에서 논리, 물리 주소가 같다.
- 하지만, 실행(Execution) 시간 바인딩 기법에서는 논리, 물리 주소가 다르다.
- 프로그램이 실행 중에는 이와 같은 가상 주소를 물리 주소로 바꾸어줘야 한다. 

* 실행 시간에 바인딩을 해주는 이유
  - 실행 시 바인딩을 해주게 되면 MMU가 필요하고, 프로그램이 실행될 때마다 변환 반복 작업을 해줘야 한다. 
  - 그러나 컴파일 시에 바인딩을 해주게 되면 사용하려고 한 메모리가 다른 프로세스가 사용하고 있는 경우 문제가 발생 (프로세스가 단 하나만 사용되는 시스템에서 사용)
  - 적재 시에 바인딩 해주는 경우,  메모리 로딩할 때 Overhead가 크기 때문에 장려하지 않음
  - 그 외에도 두 방법의 경우 원래 메모리 위치로 swap-in 해줘야하기에 비효율적이다.

### MMU (Memory Management Unit)
- 논리적 주소를 물리적 주소로 매핑해주는 하드웨어 장치
- 재배치(Relocation) 레지스터, 상한(Limit) 레지스터로 이루어짐
- 역할
  - 가상 주소를 실제 물리 주소로 변환
  - 메모리 보호를 위한 메모리 접근 제어(운영체제 영역과 사용자의 영역을 구분해 줌)
  - 캐시 메모리 관리
  - 버스 중재

### 동적 적재 (Dynamic Loading)
  - 메모리 공간을 보다 효율적을 이용하기 위해 사용
  - 메모리에 호출 전까지는 적재하지 않고 필요한 루틴을 그 때마다 적재하는 방식
  - OS로부터 특별한 지원을 필요로 하지 않음

### 스와핑 (Swapping)
- 프로세스를 일시적으로 보조 메모리로 보내졌다가 다시 메모리로 가져오는 방식
- 프로세스 스왑 시 완전히 유후 상태에 있는 것만 스와핑해줘야함
  - 입/출력이 종료된 프로세스
  - 입/출력을 프로세스로 직접하지 않고 운영체제의 버퍼로만 하도록 하는 것

### 연속 메모리 할당
- 각각의 프로세스가 메모리의 연속적인 공간을 가지게 하는 것
- 고정 분할 방식
  - 물리적 메모리를 주어진 개수만큼 영구적인 분할로 미리 나누어 각 분할에 하나의 프로세스를 적재하는 방식
  - 외부 단편화와 내부 단변화가 발생
- 가변 분할 방식
  - 프로그램의 크기를 고려하여 분할 방식을 동적으로 관리하는 방식
  - 프로그램이 종료 시 외부 단편화 발생 가능

### 동적 공간 할당 문제
- 메모리를 동적으로 할당하다 보면 남는 빈 메모리 공간(Hole)이 발생함
- First-fit
  - 첫번째로 사용이 가능한 공간을 할당한다 -> 검색 시간이 빠름
- Best-fit
  - 사용 가능한 공간들 중 가장 작은 공간을 할당 -> 나머지 관리에 용이
- Worst-fit
  - 가장 큰 공간을 할당해 줌 -> 넣은 공간에 남는 공간이 많아 다른 프로세스가 들어오기는 용이
- 일반적으로 First-fit과 Best-fit이 Worst-fit 보다 성능이 좋음

  ### 단편화 (Fragmentation)
  - 외부(External) 단편화
    - 공간 중 일부가 사용 못 하게 되는 경우
    - 어떤 알고리즘을 사용하여도 외부 단편화는 문제로 남는다
    - 통계적인 분석을 했을 때 N개의 블록이 할당되었을 때, 0.5N개의 블록이 단편화 때문에 손실된다고 한다.
    - 이는 메모리의 1/3을 사용못한다는 뜻 (50% 규칙 = 0.5N / ( N + 0.5N) = 1/3)
    - 해결 방법
      - 메모리를 고정된 크기로 분할하여 정수 배로만 할당해주는 방법
      - 압축 메모리 모든 내용들을 한 군데로 몰고 자유 공간들을 다른 한 공간으로 모아서 큰 블록을 만드는 방법 -> 항상 가능한 것이 아님, 가능하더라도 비용 문제를 생각해야함

  - 내부(Internal) 단편화
    - 메모리를 할당해줬을 때, 실제 필요한 공간보다 많이 할당하여 공간이 남는 경우

    ## 페이징(Paging)
    ### 페이징
    - 프로세스가 사용하는 메모리 공간을 잘게 나누어서 비연속적으로 할당하는 메모리 관리 기법
    - 물리 메모리는 프레임(Frame)이라는 같은 크기의 블록으로 나누어져 있고, 논리 메모리는 페이지(Page)라 불리는 같은 크기의 블록으로 나누어 진다.
    - 페이지 테이블(Page Table)
      - 각각의 프로세스가 주소 변환을 위해 사용하는 것
      - 프로세스가 가질 수 있는 페이지의 수만큼 주소 변환 엔트리를 가진다
      - 프로세스 마다 페이지 테이블이 있어 프로세스를 실행할 때마다 다른 테이블을 가져와야 하기에 문맥 교환 시간이 생김
    - Page의 크기
      - 큰 경우 : 테이블이 작아짐 -> 내부 단편화가 심해짐
      - 작은 경우 : 테이블이 커짐 -> 공간이 낭비됨
      - 디스크 입장에서는 페이지가 클수록 효율적임
    - 프레임 테이블(Frame Table)
      - OS는 어느 프레임이 할당 되어있고, 어느 프레임이 사용가능한지 알아둬야 한다.
      - 각 프레임이 어느 프로세스의 어떤 메모리에 할당 되어있는지를 빠르게 찾기 위해 사용
      - 공유 페이지(Share Page)
        - 각각의 프로세스는 다른 논리적 주소 공간을 가지고 있지만 실제 물리 메모리에서 같은 프레임으로 연결될 수 있게 해준다.

    ### PTBR (Page-Table Base Register)
      - 페이지 테이블도 메모리에 저장이 되는데, 저장된 테이블을 PRBR로 가리키도록 한다.
      - 다른 페이지 테이블을 사용할 때, PTBR만 변화시키면 되므로 문맥 교환 시간을 줄일 수 있음
      - 하지만, 메모리 접근에 대해서 두 배로 느려진다 (페이지 테이블에 접근할 때 한 번,메모리 자체를 위해서 한 번)

    ### TLB (Transaction Look-aside Buffer)
      - 매우 빠른 연관 메모리(Associative memory)로 구성됨 -> 속도가 매우 빠르지만 HW가 비쌈
      - 키(Key)와 값(Value)로 구성, 키는 페이지 번호를 값은 해당하는 프레임 번호를 저장한다.
      - 가격이 비싸므로 페이지 테이블의 전체를 저장하지 못하고 일부만을 가지고 있는다
      - 이 항목들에 대해서는 다양한 알고리즘으로 교체가 이루어짐
      
    ### 세그먼테이션 (Segmentation)
    - 논리 주소 공간을 가변적인 영역인 세그먼트들의 집합으로 정의
    - 각각의 세그먼트는 이름과 길이를 가진다
    - 세그먼트 테이블(Segment Table)
      - 각 세그먼트의 번호와 시작 주소, 크기를 가지고 있다
      - CPU에서 해당 세그먼트의 크기를 넘는 요청이 오면 인터럽트를 발생 시킨다.
    - 페이징에 비해 보호와 공유면에서 효율적이다-> 영역이 정확하게 나누어지기 때문에 접근하기 더 쉬움
    - 서로 다른 크기의 세그먼트들이 적재, 제거가 반복되면 낭비되는 공간이 생길 수 있다.

  ### Paged Segmentation
  - 페이징과 세그먼테이션의 장점을 취함
  - 세그먼트 테이블에서 주소 대신 해당 세그먼트의 페이지 테이블의 위치를 저장
  - 세그먼트 테이블에서 크기 대신에 페이지의 개수를 저장
  - 장점
    - 기존의 페이징 기법만 적용했을 때보다 페이지의 크기를 줄일 수 있음
    - 외부 단편화를 해결할 수 있음
    - 코드를 공유하기 용이함
  - 단점
    - 메모리 접근에 과정이 하나 더 늘었기에 오버 헤드가 늘어남