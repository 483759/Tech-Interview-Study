
## Process
- 컴퓨터에서 연속적으로 실행되고 있는 프로그램
- OS로부터 **자원을 할당받는 작업 단위**
- 프로세스는 각각 독립된 메모리 영역을 할당 받음
- 기본적으로 프로세스 당 최소 1개의 스레드(메인 스레드)를 가지고 있음
- 각 프로세스는 별도의 주소 공간에서 실행되며, 다른 프로세스의 변수나 자료구조에 접근할 수 없음

  ![img](https://user-images.githubusercontent.com/43779730/128197563-4ca901b3-e87b-4e9d-9f91-68effc492921.png)


### 프로세스의 주소 공간
- Code Segment (Read Only)
   - 코드가 저장되는 부분
   - 컴파일 타임에 결정되고 중간에 코드를 바꿀 수 없게 Read-Only 상태
- Data Segment (Write/Read)
  - 전역 변수 같은 데이터를 프로그램이 사용하는 데이터를 관리하는 공간
- Stack Segment
  - 호출된 함수의 수행을 마치고 복귀할 주소 및 데이터(지역 변수, 매개변수, 리턴)을 임시로 저장하는 공간
  - 런타임 되고 나면 Stack 영역의 사이즈는 변경할 수 없음 -> 무한정 할당 불가능
  - 런 타임 후 스택에 호출되는 함수(재귀 함수 등) 메모리가 너무 많으면 Stack Overflow가 발생
- Heap Segment (Write/Read)
  - 프로그래머가 필요할 때 사용하는 메모리 영역
  - 런타임 시 영역이 결정됨
  - JAVA에서는 GC에 의해 관리되는 공간

  ![memory](https://user-images.githubusercontent.com/43779730/128209228-7ec0d0bc-cb7b-4369-a602-67f7fb4fc6a6.png)


```
Q. Code 영역이 따로 있는 이유는?
A. 프로그램의 코드는 프로그램이 컴파일 된 후에 바뀔 일이 전혀 없음(Read only)
   같은 프로그램을 여러 개 실행시켜 몇 개의 프로세스가 실행 되어도 같은 Code 부분을 가지고 있으므로, 같은 프로그램의 프로세스의 경우 Code 부분을 공유하여 메모리 사용량을 줄이기 위해서 나눠져 있습니다.
```

```
Q. Data영역과 Stack 영역이 따로 있는 이유는?
함수들의 경우 LIFO 의 형태로 진행되지만, 전역 변수 등의 경우 LIFO의 형태가 아니기에 따로 구역을 나눠두었다.
```

### Process Control Block (PCB)

- CPU의 스케쥴링 상태에 따라 CPU 점유를 하게 되는데, 이 때 작업의 진행 현황을 저장하고 다시 불러오기 위해 사용되는 OS 자료 구조
- 프로세스 상태 : 생성(new), 준비(ready), 실행(running), 정지(halted), 종료(terminated)
- Program Counter(PC) : 프로세스가 다음에 실행할 명령어의 주소를 가리킴
- CPU 레지스터들 : 누산기, 색인 레지스터, 스택 레지스터, 범용 레지스터, 상태 코드 -> PC와 함께 인터럽프 발생 시 저장됨
- CPU 스케쥴링 정보 : 프로세스 우선순위, 스케쥴 큐에 대한 포인터와 다른 스케쥴 매개변수
- 메모리 관리 정보 : OS에 의해 사용되는 메모리 시스템 
- accounting 정보 : CPU가 사용된 양과 실시간, 시간 제한, 계정 번호, job 또는 프로세스 번호
- I/O 상태 정보 : 프로세스에 할당된 I/O 장치들과 열린 파일의 리스트 등을 포함


## Thread
- 프로세스가 할당받은 자원을 이용하는 **실행 흐름의 단위**
- 1개 이상의 스레드를 가질 수 있으며 멀티 스레드라고 함
- 스레드는 프로세스 내에 Stack만 따로 할당 받고 Code, Data, Heap 영역을 공유함
- 메모리를 공유하여 시스템 자원 소모가 줄어들어 응답 시간이 단축
- 동기화 문제가 있음 -> 공유된 데이터를 사용하기 때문
- 디버깅이 다소 까다로움
- 스레드를 많이 생성하면 문맥 교환(Context Switch)이 많이 일어나 성능이 저하됨

  ![다운로드](https://user-images.githubusercontent.com/43779730/128197381-018ed1ea-1a7f-4f16-a993-0f6a4af177fd.png)


### 문맥 교환(Context Switch)
- CPU는 한 번에 하나의 프로세스만 실행이 가능, 여러 프로세스를 돌아가면서 작업을 처리하는 과정
- CPU의 현재 상태를 저장하고, 나중에 연산을 재개하기 위하여 상태 복구 작업을 진행
- 문맥 교환이 진행되는 동안 시스템은 아무런 일을 못하기 때문에 이는 순수한 오버헤드이다.
- 문맥 교환에 걸리는 시간은 하드웨어의 지원에 크게 좌우됨

### Process vs Thread
|Process|Thread|
|:-:|:-:|
|독립적|종속적|
|독립적인 자원|프로세스의 자원(Code, Data, Heap) 공유|
|각각의 주소 영역을 가짐|주소 영역을 공유|
|IPC 기법으로 통신|별도 통신을 위한 작업 X|



## 멀티 프로세싱
- 다중 CPU 환경에서 여러 응용 프로그램을 병렬 처리하는 시스템
- 각 프로세스 간 메모리 구분이 필요하거나 독립된 주소 공간을 가져야 할 경우 사용
- 장점
  - 독립된 구조로 안정성이 높음
  - 프로세스 중에 하나에 문제가 생겨도 다른 프로세스에 영향을 주지 않음 -> 작업이 느려져도 멈추진 않음
  - 현대의 컴퓨터들은 대부분 멀티 코어 이상을 지원하여 멀티 프로세싱을 함
- 단점
  - 독립된 메모리 영역이다 보니 작업량이 늘어나면 문맥 교환도 늘어나 오버 헤드가 발생하여 성능 저하
  - 문맥 교환 과정에서 캐시 메모리 초기화 등 무거운 작업이 진행되고 시간이 소모하여 오버헤드가 발생


## 멀티 스레드
- 하나의 프로세스 내에서 둘 이상의 스레드가 동시에 작업을 수행하는 것을 의미
- 장점
  - 시스템 자원소모 감소 (자원의 효율성 증가)
    - 프로세스를 생성하고 자원을 할당하는 시스템 콜이 줄어 자원이 효율적으로 관리됨
  - 시스템 처리율 향상 (처리 비용 감소)
    - 스레드 간 데이터를 주고 받는 것이 간단해지기에 자원 소모가 줄어듬
    - 스레드 사이 작업량이 작아 문맥 교환이 빠름 (캐시 메모리를 비울 필요가 없음)
  - 간단한 통신 방법으로 프로그램 응답 시간 단축
    - 스레드는 프로세스 내 스택 영역을 제외한 메모리 영역을 공유하기에 통신 비용이 적음
    - 힙 영역을 공유하므로 데이터를 주고 받을 수 있음

- 단점
  - 자원을 공유하기에 동기화 문제가 발생함 (Bottleneck, deadlock)
  - 주의 깊은 설계가 필요하며 디버깅이 어려움
  - 단일 프로세스 시스템의 경우 효과를 기대하기 어려움

