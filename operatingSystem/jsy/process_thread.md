# :question: Process & Thread

#### reference
https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html<br>
https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/OS#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4<br>
https://wooody92.github.io/os/%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EB%A9%80%ED%8B%B0-%EC%8A%A4%EB%A0%88%EB%93%9C/<br>
https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Operating%20System/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80%20%EC%8A%A4%EB%A0%88%EB%93%9C.md
<hr>

## Question
1. [프로세스와 스레드의 차이를 설명하세요.](#1-process)
- 프로세스는 현재 실행중인 프로그램을 의미하며, 자신만의 고유 공간과 자원을 할당받아 사용됩니다.
- 반면, 스레드는 프로세스로부터 자원을 할당받아서 프로세스 내부에서 실행되는 작업 흐름의 단위를 의미하며, 다른 스레드와 공간, 자원을 공유하면서 사용됩니다.
<br><br>

2. [멀티 프로세스와 멀티 스레드의 차이를 설명하세요.](#3-multi-process)
- 멀티 프로세스는 하나의 프로세스가 죽더라도 다른 프로세스에는 영향을 미치지 않고 정상적으로 수행된다는 장점이 있지만, 멀티 스레드보다 많은 메모리 공간과 CPU 시간을 차지한다는 단점이 존재합니다.
- 반면, 멀티 스레드는 멀티 프로세스보다 적은 메모리 공간을 차지하고 문맥 전환이 빠르다는 장점이 있지만, 하나의 스레드에서 문제가 발생하면 전체 스레드에 영향을 미칠 수 있다는 점과 동기화 문제가 존재합니다.
- (두 방법은 동시에 여러 작업을 수행하는 점에서 동일하지만, 각각의 장단점이 있으므로 적용하는 시스템에 따라 적합한 동작 방식을 선택하고 적용해야 합니다.)
<hr>

## :nerd_face:	What I study
### 1. Process
![process](https://gmlwjd9405.github.io/images/os-process-and-thread/process.png)
- 실행중인 프로그램
- 운영체제로부터 자원을 할당받는 작업의 단위
- 프로세스 각각은 별도의 주소 공간을 할당받아 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없다.
- 다른 프로세스의 자원에 접근하려면 프로세스 간의 통신, IPC(Inter-Process Communication)를 사용해야 한다.
  - pipe, file, socket 등을 이용한 통신 방법을 사용해야 한다.
- 각각 독립된 메모리 영역(code, data, stack, heap)을 할당받는다.
    - code: 실행할 프로그램의 코드가 저장된다.
    - data: 전역변수, 정적변수, 배열이 저장된다.<br>프로그램이 시작하면 할당되고 종료되면 지워진다. 
      - data: 초기화된 데이터를 저장하는 메모리 영역
      - bss: 초기화되지 않은 데이터를 저장하는 메모리 영역
    - stack: 지역변수, 매개변수, 리턴 값이 저장된다.<br>함수의 호출과 관계되어 있다. 함수의 호출이 종료되면 지워진다.
    - heap: 사용자가 동적으로 할당한 메모리가 저장된다. <br>ex. 객체(new, malloc)

#### 1) PCB (Process Control Block)
- 특정 프로세스에 대한 중요한 정보를 저장하고 있는 운영체제 자료구조
- 프로세스 생성과 동시에 각자의 고유한 PCB가 생성된다.
- CPU Scheduling에 따라 CPU를 점유했다가 뺏기기를 반복하는데, <br>이때 작업의 진행 현황을 모두 PCB에 저장하고, 다시 CPU를 점유하게 되면 PCB에 저장되어 있는 내용을 불러와 이전에 종료됐던 시점부터 다시 작업을 수행한다.

|PCB에 저장되는 정보|Example|
|:---:|:---:|
|프로세스 식별자|PID|
|프로세스 상태|new, ready, running, waiting, terminated|
|프로그램 카운터(PC)|프로세스가 다음에 실행할 명령어의 주소|
|CPU 레지스터||
|CPU 스케쥴링 정보|우선순위 등|
|메모리 관리 정보|페이지 테이블, 세그먼트 테이블 등|
|입출력 상태 정보|프로세스에 할당된 입출력 장치들, 열린 파일 목록|
|어카운팅 정보|사용된 CPU시간, 시간제한, 계정번호 등|
<br><br>

### 2. Thread
![thread](https://gmlwjd9405.github.io/images/os-process-and-thread/thread.png)
- 프로세스로부터 자원을 할당받아 프로세스 내부에서 실행되는 실행 단위
- 한 프로세스 안에는 한 개 이상의 스레드가 존재하여 작업을 수행한다.
- 프로세스 내에서 PC register와 stack을 할당받는다. <br>code, data, heap 영역은 공유한다. -> 그러므로, 좀 더 효율적으로 통신할 수 있다.
- 동시에 메모리에 접근하기 때문에 충돌이 안나도록 조심해야 한다. (동기화 문제)
#### 1) 왜 스택은 각각의 스레드마다 할당받아 사용할까?
- 스택을 독립적으로 사용하면, 함수 호출이 독립적으로 이루어질 수 있다.<br>-> 독립적인 실행 흐름이 추가된다는 것이다.
- 독립적인 실행 흐름 단위인 스레드의 최소 조건을 맞추기 위해서, 독립된 스택을 할당한다.
#### 2) 왜 pc register는 각각의 스레드마다 할당받아 사용할까?
- pc(프로그램 카운터) 값은 스레드가 명령어의 어디까지 수행했는지를 나타낸다.
- 스레드도 CPU scheduling에 따라 점유하고 뺏기기를 반복하게 된다.
- 명령어가 연속적으로 수행되지 못하므로, 어느 부분까지 수행했는지 각각의 스레드가 기억할 필요가 있다.
<br><br>

### 3. Multi Process
- 하나의 컴퓨터에 두개 이상의 CPU를 장착한다.
- 여러 개의 CPU가 협력적으로 하나 이상의 작업(프로세스)을 동시에 처리하는 것 (병렬처리)
#### 1) 장점
- 여러 개의 자식 프로세스 중 하나에 문제가 발생하면, 문제가 발생한 프로세스만 죽고 다른 프로세스에는 영향이 미치지 않는다. (안전성이 높음)
  - 메모리 침범 문제를 OS 차원에서 해결할 수 있다.

#### 2) 단점
- [Context Switching](#5-context-switching-문맥-교환) 에서의 오버헤드
  - 각각 독립된 메모리 영역을 가지고 있어서 공유하는 메모리 영역이 없다.<br>그래서 context switching이 일어나면 캐시 메모리를 초기화하고 다시 캐시 정보를 불러오는 작업이 진행되어야 한다.
  - 이러한 무거운 작업이 진행되면 많은 시간이 소모되는 등의 오버헤드가 발생한다.
- 프로세스 간 통신 기법, IPC
  - 다른 프로세스와 메모리 영역을 공유할 수 없다. (데이터 공유 불가)
  - 그러므로 IPC라는 통신 기법을 사용해야 하는데, 이는 어렵고 복잡하기 때문에 시간이 오래걸린다.
<br><br>

### 4. Multi Thread
- 하나의 응용프로그램을 여러 개의 스레드를 만들어 각 스레드가 하나의 작업을 처리하는 것
- ex. 웹 서버
#### 1) 장점
1. 메모리 공간, 시스템 자원 소모 감소 (자원의 효율성 증가)
  - 자원을 공유하기 때문에 오버헤드가 작다.
2. 간단한 통신 방법으로 인한 프로그램 응답 시간 단축
  - stack을 제외한 모든 메모리 영역을 공유하여 데이터를 주고 받는다.<br> 통신의 부담이 적다.
3. [context switching](#5-context-switching-문맥-교환) 시, 캐시 메모리를 비울 필요가 없기 때문에 비용이 적게 들고 더 빠르다.

#### 2) 단점
- 공유 메모리를 갖기 때문에, 하나의 스레드에 문제가 생기면 전체 프로세스가 영향을 받는다.
  - 그러므로, 주의 깊은 설계가 필요하며, 디버깅이 어렵다.
- 단일 프로세스 시스템의 경우 효과를 기대하기 어렵다.
- stack 이외의 모든 영역을 공유하기 때문에, 자원 공유의 문제가 발생한다. (동기화 문제)
  - ex. 미묘한 시간차, 잘못된 변수 공유

#### 3) 왜 멀티 프로세스 대신 멀티 스레드를 사용할까?
- 프로그램을 여러 개 키는 것보다 하나의 프로그램 안에서 여러 작업을 해결하는 것이 더 효율적이기 때문이다.
- 구체적인 이유
  1. **프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어 들어 자원을 효율적으로 관리할 수 있기 때문이다.**
  2.스레드는 메모리를 공유하기 때문에 독립적인 프로세스보다 **데이터를 주고 받는 것이 간단하고** 시스템 자원 소모가 줄어들기 때문이다.
  3. **프로세스간의 통신(IPC)보다 쓰레드 간의 통신 비용이 적어 처리 비용을 감소할 수 있기 떄문이다.**
  4. 프로세스 간의 전환 속도보다 **스레드 간의 전환 속도가 더 빠르기 때문에** 응답 시간이 단축될 수 있기 때문이다. (Context Switching)

#### 4) 항상 멀티 스레드를 사용하는게 좋을까?
- 스레드를 사용하면 자원의 효율성이 증가하는 것은 큰 장점이다.
- 하지만 스레드 간의 자원 공유는 전역 변수를 공유하므로, 동기화 문제가 발생할 수 있다. 그러므로 주의가 필요하다.
<br><br>

### 5. Context Switching (문맥 교환)
- CPU가 여러 프로세스를 돌아가면서 작업을 처리하는 과정
  - CPU는 한 번에 하나의 프로세스만 실행이 가능하다.
- 동작 중인 프로세스가 대기하면서 해당 프로세스의 상태(context)를 저장하고,<br>대기하고 있던 다음 순번의 프로세스가 동작하면서 이전에 보관했던 프로세스 상태를 복구하는 과정
- Context Switching은 많은 비용이 소모된다.
  - 캐시 초기화, 메모리 매핑 초기화
- 프로세스가 스레드보다 Context Switching에 더 많은 시간을 소요한다.
  - 스레드는 stack 외의 메모리 영역을 공유하기 때문에, stack 영역만 context switching을 진행하면 된다.