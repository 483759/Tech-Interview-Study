# :question: Synchronization

#### reference
https://velog.io/@wonhee010/%EB%8F%99%EA%B8%B0vs%EB%B9%84%EB%8F%99%EA%B8%B0-feat.-blocking-vs-non-blocking<br>
https://nesoy.github.io/articles/2017-01/Synchronized<br>
https://velog.io/@underlier12/OS-24-%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C%EC%99%80-%EA%B8%B0%EC%95%84%EC%83%81%ED%83%9C<br>
https://dduddublog.tistory.com/25<br>
https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Operating%20System/%EB%8F%99%EA%B8%B0%ED%99%94%20%EB%AC%B8%EC%A0%9C.md
<hr>

## Question
1. [동기와 비동기의 차이(블로킹, 넌블로킹) 를 장단점과 함께 설명해주세요.](#1-동기와-비동기)
- 동기는 한 작업에서 요청을 보낸 후 응답을 받아야지만 다음 작업을 처리하는 방식이고, 비동기는 하나의 요청을 처리하는 동안 응답을 받지 않아도 다음 작업으로 넘어가 다른 요청을 처리하는 방식입니다.
- 즉, 동기는 직렬적으로 작업을 처리하는 방식이고, 비동기는 병렬적으로 작업을 처리하는 방식입니다.
- 동기 방식으로 작업을 처리하면 설계가 간단하고 직관적이라는 장점이 있으나, 시스템 전체 효율이 떨어질 수 있습니다.
- 반면, 비동기 방식은 설계가 복잡하고 결과를 얻는데 시간이 걸린다는 단점이 있으나, 결과를 기다리는 동안 다른 작업을 처리할 수 있으므로 자원을 효율적으로 처리할 수 있다.
<br><br>

1. [교착상태(데드락)란 무엇이며, 교착상태가 발생하는 조건을 설명해주세요.](#4-교착상태-deadlock)
- 데드락이란 서로 다른 프로세스가 서로 점유하고 있는 자원의 반납을 대기하고 있는 상태를 의미합니다.
- 이때 모든 프로세스(스레드)가 자원의 반납을 기다리고 있기 때문에, 무한 대기 상태가 되는데 이를 교착상태라고 합니다.
- 교착상태가 발생하는 조건으로는 4가지 조건이 있습니다. 4가지 조건이 모두 성립되어야 교착상태가 발생합니다.
  - 상호 배제: 하나의 자원은 한 번에 하나의 프로세스만 사용할 수 있다.
  - 점유 대기: 할당된 자원을 가진 상태에서 다른 자원을 기다립니다.
  - 비선점: 다른 프로세스가 자원의 사용을 끝낼 때 까지 자원을 강제로 뺏을 수 없습니다.
  - 순환 대기: 각 프로세스가 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있습니다.
<br><br>

3. [세마포어와 뮤텍스의 차이에 대해 설명해주세요.](#4-세마포어-vs-뮤텍스)
- 세마포어와 뮤텍스는 여러 프로세스(스레드)가 공유자원에 접근하는 것을 제어하기 위한 방법입니다.
- 세마포어는 여러 개의 프로세스가 접근 가능한 공유자원을 관리하는 기법이고,<br>뮤텍스는 한 번에 한 개의 프로세스만 공유자원에 접근 가능하도록 관리하는 기법입니다.
- 또, 세마포어는 다른 프로세스가 세마포어를 해제할 수 있지만, 뮤텍스는 lock을 획득한 프로세스만 반환할 수 있습니다.
<hr>

## :nerd_face:	What I study
### 1. 동기와 비동기

|Synchronous|Asynchronous|
|:---:|:---:|
|![sync](https://nesoy.github.io/assets/posts/20170127/Synchronous.jpg)|![async](https://nesoy.github.io/assets/posts/20170127/ASynchronous.jpg)|

#### 1) 동기 (Synchronous)
- 요청을 보낸 후 응답(결과)을 받아야지만 다음 동작으로 이루어지는 방식
- 즉, 결과가 주어질 때까지 다른 작업(요청)을 처리하지 못하고 대기해야한다.
- 데이터를 주고 받는 순서가 중요한 작업에 적합하다.
- 직렬적으로 작업을 처리하며, 비동기보다 설계가 간단하고 직관적이다.
- 결과가 주어질 때까지 아무것도 못하고 대기해야하기 때문에, 시스템 전체 효율이 떨어진다. (실제 CPU 성능이 떨어지는 것은 아님.)
- ex) 서버에 api call을 하여 데이터를 화면에 보여주는 작업을 처리할 때, 서버의 응답이 올 때까지 다음 작업이 처리되지 못하고 대기된다.
#### 2) 비동기 (Asynchronous)
- 하나의 요청을 처리하는 동안, 다른 요청도 처리하는 방식
- 요청과 결과가 동시에 이루어지지 않는다.
- 요청 순서에 상관없이, 병렬적으로 작업을 처리한다.
- 동기보다 설계가 복잡하고, 결과를 얻는데 시간이 걸린다.
- 하지만, 결과를 기다리는 시간 동안 다른 작업(요청)을 처리할 수 있으므로 동기보다 자원을 효율적으로 사용할 수 있다.
- CPU 리소스를 많이 사용하는 작업을 처리할 때, 과부하가 걸리지 않도록 조심해야 한다.
- ex) 서버에 api call을 하여 데이터를 화면에 보여주는 작업을 처리할 때, 응답이 올 때까지 기다리지 않고 바로 다음 작업을 처리한다. 이후 서버에서 응답이 오면 이벤트가 발생하고(by callback 함수) 이벤트 핸들러가 응답으로 온 데이터를 가지고 처리할 작업을 계속 수행한다.
<br><br>

### 2. 블로킹과 넌블로킹
- 동기/비동기 와는 관점이 다르다.
- 내가 직접 제어할 수 없는 대상(I/O, 멀티스레드 동기화)을 상대하는 방법이다.
  - 대상이 제한적이다.

|Blocking|Non-Blocking|
|:---:|:---:|
|![block](https://nesoy.github.io/assets/posts/20170127/Blocking.jpg)|![non-block](https://nesoy.github.io/assets/posts/20170127/Non-Blocking.jpg)|

#### 1) Blocking
- 대상의 작업이 끝날 때까지 제어권을 대상이 가진다.
- **호출된 함수**가 작업을 모두 끝낼 때까지 제어권을 계속 가지고서, 작업이 끝나기 전까지 **호출한 함수**에게 돌려주지 않는다.
#### 2) Non-Blocking
- 해당 작업 완료 여부와 상관없이 자신의 작업을 그대로 수행한다.
- **호출된 함수**가 작업을 끝내지 못했더라도 바로 제어권을 돌려줘서(return) **호출한 함수**가 다른 작업을 진행할 수 있도록 한다.
<br><br>

### 3. 동기/비동기 vs 블로킹/넌블로킹
:star: 호출되는 함수의 작업 완료 여부를 누가 신경쓰느냐

|Synchronous|Asynchronous|
|:---:|:---:|
|호출하는 함수가 작업 완료 여부를 계속 확인|호출한 함수가 작업 완료 여부 신경 X|

- Synchronous
  - 호출하는 함수가 호출되는 함수의 작업이 끝난 후 return을 기다린다.
  - 호출되는 함수로부터 바로 return을 받더라도 작업 완료 여부를 호출 함수 스스로 확인한다.
- Asynchronous
  - 호출하는 함수가 호출되는 함수에게 callback을 전달한다.
  - 호출되는 함수가 작업을 끝내면 전달받은 callback을 실행한다.
  - 호출한 함수는 callback을 실행하기 전까지 작업 완료 여부를 신경쓰지 않는다.
<hr>

:star: 호출되는 함수가 바로 return하느냐 마느냐

|Blocking|Non-Blocking|
|:---:|:---:|
|호출된 함수가 작업이 다 끝날 때까지 return X|호출된 함수가 바로 return O|

- Blocking
  - 호출된 함수가 작업을 모두 끝낼 때까지 제어권을 가지고 있는다.
  - 제어권을 받지 못한 호출한 함수는 제어권이 돌아올 때까지 계속 대기한다.
- Non-Blocking
  - 호출된 함수가 작업을 끝내지 못했더라도 바로 return해서 호출한 함수에게 제어권을 넘겨준다.
  - 제어권을 받은 호출한 함수가 다른 작업을 진행할 수 있도록 한다.
<hr>

#### :star2: 동기/비동기, 블로킹/넌블로킹 조합 :star2:

|||
|---|---|
|![overall](https://media.vlpt.us/images/wonhee010/post/be726da1-3605-475c-b7ab-93fe89636a8e/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202020-08-16%20%EC%98%A4%ED%9B%84%205.04.49.png)|![vs2](https://media.vlpt.us/images/wonhee010/post/bc20459f-02fe-431a-a1d0-8d5016a964f9/zKF0CgK.png)|

- Synchronous + Blocking
  - 결과가 처리되어 나올 때까지 기다렸다가 return값으로 결과를 전달한다.
- Asynchronous + Non-Blocking
  - 작업 요청을 받아서 별도의 프로세서에서 작업을 수행하도록 하고 거의 바로 return한다.
  - 응답(결과)는 별도의 작업 후, callback 함수를 호출하여 간접적으로 전달한다.
- Synchronous + Non-Blocking
  - 결과가 없다면 바로 return한다.
  - 결과가 있으면 바로 결과를 return한다. (결과가 생길 때까지 계속 완료되었는지 확인)
- Asynchronous + Blocking
  - 호출되는 함수가 바로 return하지 않는다.
  - 호출하는 함수는 작업 완료 여부를 신경쓰지 않는다.
  - 큰 이점이 없어서 일부러 이 방식을 사용하진 않는다고 한다.
  - ex. Nodejs + MySQL
<br><br>

### 4. 교착상태 (Deadlock)
![thread](https://media.vlpt.us/images/underlier12/post/9009d13f-0296-4219-b82c-d7e30c42bf91/image.png)
- 서로 다른 프로세스가 서로 점유하고 있는 자원의 반납을 대기하고 있는 상태
- 첫 번째 스레드는 두 번째 스레드가 점유하고 있는(lock) 객체의 반납을 기다리고 있고, 두 번째 스레드는 첫 번째 스레드가 점유하고 있는(lock) 객체의 반납을 기다리고 있는 상황에 일어난다.
- 모든 스레드가 lock이 풀리기를 기다리고 있기 때문에 무한 대기 상태가 된다. -> **교착상태**
#### 1) 교착상태의 4가지 조건
```4가지 조건이 모두 성립해야 된다. 하나라도 성립되지 않으면 데드락은 해결 가능하다.```
- 상호 배제(Mutual exclusion)
  - 공유 자원에 대한 접근 권한이 제한된다.
  - 하나의 자원은 한 번에 하나의 프로세스만 사용할 수 있다.
- 점유 대기(Hold and wait)
  - 최소 하나의 자원에 대한 접근 권한을 가지고 있는 프로세스가, 권한을 계속 가지고 있는 상태에서 다른 자원에 대한 접근 권한을 요구할 수 있다.
  - 자신이 점유하고 있는 자원을 포기하지 않고, 다른 프로세스가 사용하고 있는 자원에 대한 접근 권한을 가져오기 위해 대기한다.
- 비선점(No preemption)
  - 한 프로세스가 다른 프로세스에 할당된 자원의 사용이 끝나서 반납할 때까지 강제로 빼앗을 수 없다.
- 순환 대기(Circular wait)
  - 프로세스 P0은 P1이 점유한 자원을 점유하기 위해 대기하고 P1은 P2가 점유한 자원을 대기하고 Pn은 P0이 점유한 자원을 요구한다. -> 그 관계에 순환 형태로 사이클이 존재한다.
  - 프로세스의 집합에서 순환 형태로 자원을 대기하고 있어야 한다.
#### 2) 교착상태 방지
- 예방
  - 4가지 조건 모두 만족하지 못하도록, 조건 하나를 제거한다.
  - 자원 낭비가 심하다.
  ```
  1. 상호 배제 제거: 공유 자원 중 많은 경우가 한번에 한 프로세스만 사용 가능하기 때문에 제거하기 힘들다.
  2. 점유 대기 제거: 프로세스를 실행하기 전, 모든 자원을 할당한다.
  3. 비선점 제거: 자원을 점유하고 있는 프로세스가 다른 자원의 권한을 요청할 때, 현재 점유하고 있는 자원을 반납하도록 한다.
  4. 순환 대기 제거: 자원에 고유번호를 할당하고 순서대로 자원을 요구하도록 한다, 대부분의 교착상태 방지 알고리즘의 목적이다. 
  ```
- 회피
  - 알고리즘이 프로세스가 교착상태가 발생하지 않도록 한다. (**은행원 알고리즘**)
  - 프로세스가 자원을 요구할 때, 시스템이 자원을 할당한 후의 교착상태 여부를 검사하여 교착상태를 회피하는 기법이다.
    - 안정상태면 자원 할당, 교착상태면 다른 프로세스들이 자원을 반납할 때까지 대기
- 회복
  - 교착상태를 허용하고, 이를 해결한다.
  - 교착상태를 만든 프로세스를 종료하거나, 할당된 자원을 반납시킨다.
  ```
  1. 프로세스 종료
    - 교착상태의 프로세스를 모두 중지한다.
    - 교착상태가 사라질 때까지 프로세스를 하나씩 종료시킨다.
  2. 할당 자원 반납
    - 교착상태의 프로세스를 정지시키고, 자원을 먼저 점유하여 다른 프로세스에게 할당한다.
    - 우선 순위가 낮은 프로세스, 수행 횟수가 적은 프로세스를 위주로 프로세스 자원을 선점한다.
  ```
- 탐지
  - 교착상태를 허용하고, 이를 해결한다.
  - 자원 할당 그래프를 통해 교착상태를 탐지할 수 있다.
  - 자원을 요청할 때마다 탐지 알고리즘을 실행하므로, 오버헤드가 발생한다.
- 무시
  - 회복/탐지 과정를 할 때, 성능 저하가 심하다면 무시한다.
#### 3) 기아상태 (Starvation)
- 특정 프로세스의 우선 순위가 낮아서 원하는 자원을 계속 할당받지 못하는 상태
- 해결 방법
  - 우선순위를 수시로 변경한다.
  - 오래 기다린 프로세스의 우선순위를 높여준다.
  - 큐를 사용하여, 요청이 들어온 순으로 자원을 할당받을 수 있도록 한다.
```
cf)
교착상태: 여러 프로세스가 동일한 자원에 대해 접근 권한을 요청할 때 발생한다.
기아상태: 여러 프로세스가 부족한 자원을 점유하기 위해 경쟁할 때 발생한다, 특정 프로세스는 영원히 자원 할당이 안되는 상황
```
#### cf) 식사하는 철학자 문제
- https://jjangsungwon.tistory.com/104?category=954112
<br><br>

### 5. 프로세스 동기화 (Process Synchronization)
- 다중 프로세스 환경에서 자원 등에 한 프로세스만이 접근이 가능하도록 한다.
  - 프로세스는 서로 메시지를 보내고, 프로세스 내부에서는 스레드끼리 자원을 공유한다.
  - 이때, 공유된 자원에 여러 프로세스, 스레드가 동시에 접근할 수 있기 때문에 '동기화'에 대한 문제가 발생할 수 있다.
  - 그러므로, 이 문제를 방지하기 위해 여러 프로세스, 스레드에게 하나의 자원에 대한 처리 권한을 주거나, 순서를 조정한다.
- 프로세스 동기화가 제대로 되지 않으면, 데이터의 일관성이 깨지기 때문에 주의해야 한다.
- 프로세스 동기화 기법에는 크게 유저 모드의 동기화 기법, 커널 모드의 동기화 기법이 있다.
  - 유저 동기화
    - 커널의 힘을 빌리지 않는다. (커널의 코드가 실행되지 않는다.)
    - 성능의 이점은 있지만, 기능에 제한이 있다.
    - Critical Section
  - 커널 동기화
    - 커널에서 제공하는 동기화 기능을 이용한다.
    - 사용자 모드에서 커널 모드로 변경이 필요하기 때문에, 성능 저하가 있다.
    - 성능의 저하는 있지만, 다양한 기능을 사용할 수 있다.
    - Mutex, Semaphore

#### 1) 임계구역 (Critical Section)
- 둘 이상의 프로세스(스레드)가 동시에 접근하면 안되는 공유자원의 코드 영역
- 한 임계구역에 하나의 스레드 혹은 프로세스만 접근이 가능하다.
  - 공유자원을 여러 프로세스가 동시에 접근할 때, 잘못된 결과가 나올 수 있기 때문이다.
  - ex) 공유하는 변수 사용, 동일 파일 사용 등
- 임계구역에 접근하는 것을 제어하기 위해, 뮤텍스, 세마포어와 같은 메커니즘을 사용한다.
```임계구역 접근 요청 -> 필요시 대기 -> 임계구역 들어와 처리 -> 임계구역 나감```
- :star: 임계구역에서 발생하는 문제들을 해결하기 위한 조건 ```3가지 조건이 모두 성립해야 된다.```
  - 상호 배제(Mutual exclusion)
    - 임계구역에 대한 접근 권한이 제한된다.
    - 하나의 프로세스가 임계구역에서 동작중이면 다른 프로세스는 들어갈 수 없다.
  - 진행(Progress)
    - 임계구역에 들어간 프로세스가 없다면, 어느 프로세스가 들어갈 것인지 잘 선택해야 한다.
  - 유한 대기(Bounded waiting)
    - 기아상태를 방지하기 위해, 한 번 들어갔다 나온 프로세스는 제한을 준다.
#### 2) 세마포어 (Semaphore)
- 공유된 자원의 데이터에 여러 프로세스(스레드)가 접근하는 것을 막는 메커니즘
- 공유자원에 접근할 수 있는 프로세스의 최대 허용치만큼 동시에 사용자가 접근하여 사용할 수 있다.
- 동시에 접근할 수 있는 허용 가능 개수를 가지고 있다. **(counter)**
  - 공유자원에 접근할 수 있는 스레드 혹은 프로세스의 수를 나타낸다.
  - 공통으로 관리한다.
- 각 프로세스는 세마포어 값을 확인하고 변경할 수 있다.
  - 세마포어를 사용하는 프로세스는 세마포어 값을 확인하고, 자원을 사용하는 동안에는 그 값을 변경함으로써 다른 세마포어 사용자들이 기다리도록 한다.
- 세마포어는 소유할 수 없다.
``` 
프로세스가 자원에 접근하려고 할 때, 세마포어는 아무도 사용하지 않는 자원의 개수이다.
즉, 사용하지 않는 자원이 여러 개일 때, 하나의 프로세스가 접근할 때마다 프로세스는 하나씩 줄어든다.
0개가 되면 아무도 사용하지 않는 자원이 나올때 까지 대기해야한다. 아무나 먼저 나와야만 들어갈 수 있다.
```
#### 3) 뮤텍스 (Mutex)
- 공유된 자원의 데이터에 여러 프로세스(스레드)가 접근하는 것을 막는 메커니즘
- 임계구역를 가진 스레드들의 running time이 겹치지 않도록, 단독으로 실행하도록 하는 기술이다.
- **뮤텍스 객체를 두 스레드가 동시에 사용할 수 없다.**
  - 공유자원에 대한 접근을 조율하기 위해 locking과 unlocking을 사용한다. (1개의 lock을 갖는 Locking 메커니즘)
  - lock을 가지고 있는 경우만 공유자원에 대한 접근 가능, 또한, lock을 가진 스레드만 공유자원을 반납할 수 있다.
```
프로세스가 자원에 접근하려고 할 때, 뮤텍스는 자원에 접근하기 위해 필요한 열쇠이다.
즉 뮤텍스는 한 프로세스가 자원에 대한 열쇠를 가지고 자원에 접근하고, 
다른 프로세스는 그 프로세스가 나오기를 기다렸다가 열쇠를 건네받아 자원에 접근할 수 있다.
```
#### 4) 세마포어 vs 뮤텍스

||Semaphore|Mutex|
|:---:|:---:|:---:|
|공유자원에 접근 가능한 프로세스(동기화 대상)|여러 개(설정한 카운트만큼)|1 개|
|소유 가능 여부|불가능|가능|
|해제(unlocking)|다른 프로세스들도 가능|lock을 획득한 프로세스만 가능|
|범위|시스템|프로세스|
|위치|파일 시스템 상의 파일 형태|프로세스 종료 시 정리|
||Mutex로 변환 가능|Semaphore로 변환 불가능|

- Semaphore
  - 여러 개의 프로세스가 접근 가능한 공유자원을 관리하는 기법
  - **관리하는 동기화의 대상이 여러 개일때 사용한다.**
  - 다른 프로세스가 세마포어를 해제할 수 있다.
  - 자원의 상태를 나타내는 일종의 변수(counter)로써 소유할 수 없다.
  - 세마포어는 뮤텍스가 될 수 있다.
  - 세마포어는 시스템 범위에 걸쳐있고 파일 시스템 상의 파일 형태로 존재한다.
- Mutex
  - 한 번에 한 개의 프로세스만 공유자원에 접근 가능하도록 관리하는 기법
  - **관리하는 동기화의 대상이 하나일 때 사용한다.**
  - lock을 획득한 프로세스만 lock을 반환할 수 있다.
  - 자원을 점유한 프로세스(스레드)가 잠시 소유했다가 작업이 끝나면 반환한다. (locking)
    - 소유주가 책임을 진다.
  - 뮤텍스는 세마포어가 될 수 없다.
  - 뮤텍스는 프로세스 범위를 가지며, 프로세스가 종료될 때 자동으로 정리된다.
- cf) 위의 두 기법들을 쓰더라도 데이터 무결성을 보장할 수 없고 교챡상태(Deadlock)이 발생할 수 있다. 