# :question: CPU Scheduling

#### reference
https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Operating%20System/%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%AC%EC%9D%98%20%EC%A2%85%EB%A5%98.md<br>
https://www.crocus.co.kr/1373<br>
https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/OS#cpu-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%AC
<hr>

## Question
1. [자신이 알고 있는 CPU 스케줄링을 선점형, 비선점형으로 나누어 특징을 설명해주세요.](#2-선점-스케줄링-기법)
- 프로세스의 작업이 끝나면, CPU를 어떤 프로세스에 할당해줄지 선택해야 하는데 이를 위해 CPU 스케줄링을 사용합니다.
- 선점형 스케줄링 방식은 프로세스가 CPU를 점유하고 있어도 우선순위가 높은 프로세스가 오면 CPU를 빼앗을 수 있습니다. 대표적으로 RR 스케줄링이 선점형 스케줄링입니다. 모든 프로세스는 같은 크기의 CPU 할당시간을 가지게 되고, 그 시간 안에 프로세스가 끝나지 않으면 해당 프로세스는 ready 큐 뒤로 들어가는 선입선출 방식입니다.
- 비선점형 스케줄링 방식은 프로세스가 CPU를 점유하고 있는 경우 다른 프로세스가 CPU를 강제로 뺏지 못합니다. 대표적으로, FCFS 스케줄링이 있습니다. ready 큐에 도착한 순서대로 프로세스에 CPU를 할당하는 방식입니다.
<br><br>

2. 1에서 설명한 각 CPU 스케줄링의 단점을 설명해주세요.
- RR 스케줄링은 CPU 할당시간을 잘 설정하지 않으면 문제가 발생합니다. CPU 할당시간을 time slice 또는 time quantum 이라고 부릅니다. 그래서 time slice가 크면 FCFS와 같은 방법이 되고, time slice가 작으면 context switching이 자주 발생하여 오버헤드가 커진다는 단점이 있습니다.
- 또한, FCFS 스케줄링은 작업 시간이 짧은 프로세스가 시간이 긴 프로세스보다 뒤에 들어오면 오랜 시간 대기해야 하기 때문에 비효율적이라는 단점이 있습니다.
<br><br>

3. [선점방식과 비선점방식을 장/단점을 비교하여 설명해주세요.](#1-선점--비선점)
- 선점방식은 우선 순위가 높은 프로세스가 빠르게 처리할 수 있다는 장점이 있지만, Context Switching가 자주 발생하여 오버헤드가 증가한다는 단점이 있습니다.
- 비선점방식은 CPU를 중간에 가로채지 않기 때문에 응답시간 예측이 용이하다는 장점이 있지만, 중요한 작업 또는 작업 시간이 짧은 프로세스가 오래 기다리는 경우가 발생할 수 있다는 단점이 있습니다.
<hr>

## :nerd_face:	What I study
### 1. 스케줄러
- 어떤 프로세스에게 자원을 할당할지 결정하는 운영체제의 커널 모듈
    - 프로세스들은 자신이 종료될 때까지 수많은 큐들을 돌아다닌다.
    - 자원은 제한되어 있기 때문에, 운영체제는 이 큐 안에 있는 프로세스 중 하나를 선택하여 자원을 나눠줘야 한다.
    - 어떤 프로세스를 선택할건지 결정하는 것이 **스케줄러**이다.

#### 1) 프로세스를 스케줄링하기 위한 Queue
- 작업 큐(Job Queue): 현재 시스템 내에 있는 모든 프로세스의 집합
- 준비 큐(Ready Queue): 현재 메모리 내에 있으면서 CPU를 할당받아 실행되기를 기다리는 프로세스의 집합
- 장비 큐(Device Queue): 장치마다 I/O작업을 대기하고 있는 프로세스의 집합

#### 2) Queue 내의 프로세스들을 넣고 빼주는 Scheduler
1. 장기 스케줄러
    - 메모리는 한정되어 있는데 많은 프로세스들이 메모리에 한꺼번에 올라올 경우, 대용량 메모리(일반적으로 디스크)에 임시로 저장한다. <br>이 pool(디스크) 내에 저장되어 있는 프로세스 중 어떤 순서로 프로세스를 메모리에 올릴지 결정한다.
    - 디스크와 같은 장치에 작업을 저장해두고, 필요할 때 실행할 작업을 job 큐에서 꺼내서 ready 큐에 넣어 메인 메모리에 적재한다.
    - **메모리와 디스크 사이의 스케줄링 담당** <- 호출되는 빈도가 적음
    1. 프로세스에 메모리 및 각종 리소스를 할당
    2. 실행중인 프로세스의 수 제어
    3. 프로세스의 상태
        - New -> Ready
        - Running(or Ready) -> Terminated
2. 단기 스케줄러
    - **CPU와 메모리 사이의 스케줄링 담당** <- 호출되는 빈도가 매우 많음
    1. ready 큐에 존재하는 프로세스 중 어떤 프로세스를 실행시킬지 결정한다.
    2. CPU에 필요한 데이터를 확보해주고 메모리에 있는 프로세스 중 하나를 선택해서 CPU에 할당한다. 
    3. 미리 정한 스케줄링 알고리즘에 따라 CPU에 할당할 프로세스가 선택된다. (scheduler dispatch)
    4. 프로세스의 상태
        - Ready -> Running -> Waiting -> Ready 
3. 중기 스케줄러
    - 시분할 시스템에서 추가로 사용하는 스케줄러<br> (참고로 시분할 시스템에는 프로세스가 곧바로 메모리에 올라가 Ready 상태가 되기 때문에 장기 스케줄러가 없다.)
    - 메모리에 대한 가중을 완화시켜주기 위해 만들어졌다.
    - CPU를 차지하기 위한 경쟁이 심해질 때, 여유공간을 마련하기 위해 <br>우선순위가 낮은 프로세스들을 제거한 뒤, 나중에 경쟁이 완화되었을 때 다시 디스크에서 메모리로 불러와 중단되었던 지점부터 실행시킨다. (swapping)
    1. 실행 중인 프로세스의 수 제어
    2. 메모리에 너무 많은 프로세스가 동시에 올라가는 것을 조절
    3. 프로세스의 상태
        - Ready -> Suspended(Stopped)

#### 3) Process의 상태
![status](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F993FEE355BB5F4902136B4)
- 생성(New): 프로세스 생성 상태
- 준비(Ready): 프로세스가 CPU에 할당되기를 기다리는 상태 (메모리에 올라와있는 상태)
- 실행(Running): 프로세스가 CPU에 할당되어 명령어들이 실행 중인 상태 
- 대기(Waiting/Blocked): 프로세스가 입출력, 시그널 수신 등 이벤트를 기다리고 있는 상태
- 종료(Terminated): 프로세스 종료 상태
- 중단(Suspended): 외부적인 이유로 프로세스의 수행이 중단된 상태, 스스로 Ready로 돌아갈 수 없다.<br>cf) Blocked 상태는 다른 I/O를 기다리는 상태이기 때문에 스스로 Ready 상태로 돌아갈 수 있다.
<br><br>

### 2. CPU 스케줄링
- 스케줄링 대상은 **Ready Queue**에 있는 프로세스들이다.
- 즉, 프로세스의 작업이 끝나면, CPU를 어느 프로세스에 할당해줄 것인지 선택하는 알고리즘
- 스케줄링 목적
  - 오버헤드 최소화
  - 단위 시간당 처리량 최대화
  - 기아 상태 최소화
#### 1) 선점 & 비선점
- 선점(Preemptive)
  - 프로세스가 CPU를 점유하고 있는 동안, 다른 프로세스가 CPU를 강제로 점유할 수 있다.
  - 즉, 프로세스가 작업을 처리하고 있는 동안, 다른 프로세스가 CPU를 강제로 뺏어 실행할 수 있다.
  - 우선 순위가 높은 프로세스를 빠르게 처리할 수 있다.
  - Context Switching이 자주 발생하여 오버헤드가 증가한다.
- 비선점(Non-Preemptive)
  - 한 프로세스가 CPU를 점유했다면 I/O, 인터럽트 또는 프로그램 종료가 발생할 때까지, 다른 프로세스가 CPU를 뺏지 못한다.
  - 일괄 처리 방식에 적합하며, 응답시간 예측이 쉽다.
  - 우선순위가 높은 작업이 waiting 상태로 대기하는 상태가 발생하고, 작업 시간이 짧은 프로세스가 오랜 시간 대기하게 되면 비효율적이다.<br>-> 기아상태가 발생할 수 있다.

#### 2) 선점 스케줄링 기법
- 우선순위가 높은 작업이 진행중인 작업을 중단시키고 CPU를 사용할 수 있는 기법.
1. ***SRT(Shortest Remaining Time) 스케줄링***
   - 짧은 시간 순서대로 프로세스를 수행한다.
   - 현재 CPU에서 실행 중인 프로세스의 남은 시간보다 **더 짧은 시간이 소요되는 프로세스가 ready 큐에 도착하면 CPU가 강제로 뒤에 들어온 프로세스에 할당된다.**
   - 처리 시간이 긴 프로세스는 거의 영원히 CPU를 할당받을 수 없어 **기아상태**가 발생할 수 있다.
   - 새로운 프로세스가 도착할 때마다 스케줄링을 다시 하기 때문에 **CPU 사용시간을 측정할 수 없다.**
2. ***RR(Round Robin) 스케줄링***
   - 일정 시간(time slice)을 정하여 하나의 프로세스가 CPU를 할당 받아 이 시간동안 수행하고 다시 대기 상태로 돌아간다.
     - 각 프로세스는 **동일한 크기의 time slice를 갖는다.**
   - 즉, 한 프로세스가 종료되기 전이라도 time Slice가 끝나면 다른 프로세스에게 CPU를 넘겨준다.
     - 위의 작업을 모든 프로세스가 돌아가면서 진행한다.
     - **time slice가 끝나면 다음 프로세스에 CPU를 넘겨주고, ready 큐의 제일 뒤로 가서 다시 줄을 선다.**
     - 일정 시간을 **Time Slice**(**Time Quantum**)라고 부른다.
   - time slice가 크면 FCFS와 같게 되고, <br>작으면 Context Switching이 잦아져서 오버헤드가 증가한다.
   - 각 프로세스에 대한 **응답 시간이 짧기 떄문에,** 대화식 real time system에 적합하다.
   - 프로세스가 CPU를 기다리는 시간이 CPU를 사용할 만큼 증가하기 때문에 공정한 스케줄링 방법이라고 할 수 있다.
3. ***다단계 큐(Multi-level Queue) 스케줄링***
    - **ready 큐를 여러 개로 분할**해 관리하는 스케줄링 방법
    - 프로세스를 그룹으로 나누어, 각 그룹에 따라 ready 큐를 둔다.
      - **각 큐마다 규칙(ex. 우선순위, CPU 할당 시간 등)을 다르게 정할 수 있다.**
      - CPU를 기다리기 위해 프로세스들이 여러 줄로 대기하고 있다.
    - ex) 우선순위를 규칙으로 하는 ready 큐에서는,
      - 항상 우선순위가 높은 큐의 프로세스에 CPU를 할당한다.
      - 우선순위가 낮은 큐에서 CPU를 점유하고 있는 중이어도, 우선순위가 더 높은 큐에 프로세스가 도착하면 CPU를 뺏긴다. (선점)
      - 우선순위가 낮은 큐들에서 기아상태가 발생하지 못하도록, 각 큐마다 다른 time slice를 설정해준다.
      - 우선순위가 높은 큐는 작은 time slice
      - 우선순위가 낮은 큐는 큰 time slice
4. ***다단계 피드백 큐(Multi-level Feedback Queue) 스케줄링***
    - 다단계 큐 스케줄링 기법과 기본 개념은 동일하다.
    - 프로세스가 **하나의 큐에서 다른 큐로 이동가능하다**는 특징이 있다.
        1. 처음엔 모든 프로세스가 가장 우선순위가 높은 큐에서 CPU 점유를 대기한다.
        2. **각 ready 큐마다 time slice를 다르게 부여한다.**
        3. 자신의 time slice가 끝났는데 아직 작업이 끝나지 않았다면, 한단계 낮은 우선순위의 큐로 프로세스를 옮긴다.<br>-> 실행 시간이 긴 작업에게 불이익을 준다.<br>-> 아직 time slice가 남았다면 원래 큐 그대로 있는다.
        4. **우선순위가 낮은 아래의 큐에 있는 프로세스에서 기아상태가 발생하면 이를 우선순위가 한단계 높은 위의 큐로 옮길 수 있다.**
    - 우선순위가 낮은 큐에서 CPU를 점유하고 있는 중이어도, **우선순위가 더 높은 큐에 프로세스가 도착하면 CPU를 뺏긴다.** (선점)
        - 상위 큐일수록, 우선순위가 높고 time slice가 작다.
        - 처리 시간이 짧은 작업에 유리하다. (우선순위 큐이기 때문에, 시간이 짧은 프로세스를 먼저 처리하게 된다.)
        - interrupt가 잦은 입출력 위주 작업에 우선권을 준다.
    - ***대부분의 상용 운영체제***에서 다단계 피드백 큐 스케줄링 기법을 사용한다.
        - 프로세스의 성격에 맞게 각 큐마다 다른 스케줄링 방식을 사용한다.
        - 최대한 효율을 높일 수 있는 기법을 선택한다.

#### 3) 비선점 스케줄링 기법
- CPU를 할당받은 작업이 끝날때까지 다른 작업이 CPU 를 사용할 수 없는 기법.
1. ***FCFS(First Come First Served) 스케줄링***
    - **ready 큐에 먼저 도착한 프로세스가 먼저 CPU를 할당**하는 스케줄링 방법
    - 실행 시간이 짧은 프로세스가 뒤에 도착하면, 대기 시간이 길어져 비효율적이다.
    - 대화식 real time system에는 적합하지 않다.
2. ***SJF(Shortest-Job-First) 스케줄링***
    - 다른 프로세스가 먼저 도착했더라도, **처리 시간이 짧은 프로세스부터** CPU를 할당하는 스케줄링 방법
    - FCFS 기법보다 평균 대기 시간이 감소하고, 시스템 내의 대기 프로세스 수가 최소화된다.
    - 짧은 작업에 유리하다.
    - 처리 시간이 긴 프로세스는 거의 영원히 CPU를 할당받을 수 없어 기아상태가 발생할 수 있다.
    - 선점, 비선점 방식 모두 가능하다.
    - but, 매우 비현실적인 방법이다.
        - 모든 프로세스의 CPU 점유 시간을 알 방법이 없다.
        - 프로세스를 실행 할 때 많은 변수가 존재하기 때문에, CPU 점유 시간을 알기 위해서는 실제로 프로세스를 실행하여 측정하는 수밖에 없다.
        - 이렇게 하면 오버헤드가 매우 큰 작업이 발생한다.
3. ***HRN***(***Hightest Response-ratio Next***)
   - 우선순위를 계산하여 점유 불평등을 보완한 스케줄링 방법<br>SJF의 단점 보완
   - **우선순위 = (대기시간 + 실행시간) / (실행시간)**
4. ***Priority 스케줄링***
   - **우선순위가 높은 프로세스가 먼저** 선택되는 스케줄링 방법
   - 우선순위는 정수로 표현되고, 작은 숫자가 우선순위가 높다.
   - 처리 시간이 긴 프로세스는 거의 영원히 CPU를 할당받을 수 없어 기아상태가 발생할 수 있다.
     - 이러한 문제를 극복하기 위해, 아무리 우선순위가 낮은 프로세스라도 오래 기다리면 우선순위를 높여주는 **aging** 방법을 사용한다.
   - 선점, 비선점 모두 가능하다.
     - 선점형 스케줄링: 더 높은 우선순위의 프로세스가 도착하면 실행중인 프로세스를 멈추고 CPU를 할당한다.
     - 비선점형 스케줄링: 더 높은 우선순위의 프로세스가 도착하면 ready 큐의 head에 넣는다.