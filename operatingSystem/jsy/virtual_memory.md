# :question: Virtual Memory

#### reference
https://baked-corn.tistory.com/20<br>
https://jennysgap.tistory.com/entry/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-%EA%B8%B0%EC%B4%88-17-Demand-Paging-1<br>
https://kahee.github.io/til/2019/12/26/TIL_1226/<br>
https://velog.io/@codemcd/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS-15.-%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC
<hr>

## Question
1. [가상 메모리가 필요한 이유를 하는 일과 관련지어 설명해주세요.](#1-가상-메모리virtual-memory)
실행되는 코드의 전부를 물리 메모리에 존재시켜야 했고, 메모리 용량보다 큰 프로그램은 실행시킬 수 없었다. 또한, 여러 프로그램을 동시에 메모리에 올리기에는 용량의 한계와, 페이지 교체등의 성능 이슈가 발생하게 된다. 또한, 가끔만 사용되는 코드가 차지하는 메모리들을 확인할 수 있다는 점에서, 불필요하게 전체의 프로그램이 메모리에 올라와 있어야 하는게 아니라는 것을 알 수 있다.
실제 메모리를 보조하여 프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 해주는 역할입니다.

<br><br>

1. [요구 페이징이란 무엇이고, 요구 페이징에서 Page Fault가 발생했을 때, 처리되는 Page 교체 순서에 대해 설명해주세요.](#2-요구-페이징demand-paging)
요구 페이징이란 가상 메모리 관리 방법입니다.
프로그램 실행 시작 시에 프로그램 전체를 디스크에서 물리 메모리에 적재하는 대신, 초기에 필요한 것들만 적재하는 전략을 요구 페이징이라고 합니다.
가상 메모리 시스템에서 많이 사용됩니다.
프로세스 실행에 실제 필요한 페이지들만 메모리로 읽어옴으로써, 사용되지 않을 페이지를 가져오는 시간과 메모리 낭비를 줄일 수 있습니다.
<hr>

## :nerd_face:	What I study
### 1. 가상 메모리(Virtual Memory)
- 다중 프로그래밍 환경에서는 많은 프로세스들을 동시에 메모리에 올려둬야한다.
- 하지만, 프로세스 전체를 메모리 내에 올리는 것은 효율적이지 않다.
  - 가상 메모리를 사용하기 전까진 실행되는 프로그램 전부를 메모리 내에 올려야했다.
  - 메모리 용량보다 큰 프로그램은 메모리 내에 올릴 수 없으므로, 실행시킬 수 없었다.
  - 오류 처리하는 부분이나 배열 등으로 할당한 부분은 프로세스가 잘 실행되고 있으면 필요 없는 부분이다.
  - 가끔만 사용되는 코드가 메모리 공간을 불필요하게 차지하고 있어, 비효율적이다.
- 위의 문제를 해결하기 위해, **프로세스 전체가 아닌 필요한 일부분만 실제 메모리에 올려 실행이 가능하도록 하는** Virtual memory 기법을 사용한다.
- 프로세스 공간 중 일부는 물리적 메모리에 적재되고, 일부는 디스크의 swap area에 존재하게 된다.
- Virtual memory는 Demand paging 기법과 Demand segmentation 기법으로 구현될 수 있다.
  - 대부분의 경우 Demand paging 방식을 사용한다.
#### 1) 프로그램의 일부만 메모리에 올렸을 때의 장점
- 프로그램이 물리 메모리 공간보다 커도 실행이 가능하다.
- 물리 메모리 크기에 제약을 받지 않는다.
  - 물리 메모리의 여유 공간이 얼마나 남았는지 시작 전에 확인할 필요가 없다.
- 더 많은 프로그램을 동시에 실행할 수 있게 된다.
- 응답시간은 유지되고, CPU 이용률과 처리율을 높아진다.
- [swap](memory.md)에 필요한 I/O(디스크와 메모리 간의 I/O)가 줄어드므로, 프로세스들이 빠르게 실행된다.
<br><br>

### 2. 요구 페이징(Demand Paging)
- 메모리 관리 메커니즘(MMU 메커니즘)을 사용해서 여러 프로세스가 시스템의 메모리를 효율적으로 공유할 수 있도록 하는 기법
- 프로그램 전체가 아니라, CPU의 요청이 들어오면 필요한 부분만 메모리에 적재하고, 페이지들이 실행 과정에서 실제로 필요할 때 해당 부분을 메모리로 적재한다.
- 사용하지 않을 페이지를 가져오는 시간과 메모리 낭비를 줄일 수 있다.
- Page table을 사용하여 가상 메모리를 관리한다.
- 운영체제가 page fault를 해결하기 위한 과정으로 사용한다.
#### 1) Page table
- 프로세스 1개 당 1개씩 존재한다.
- 각 page table이 저장되어 있는 주소를 page table base register가 저장하고 있다.
- page table은 운영체제로부터 관리되며, MMU가 접근하여 읽는다.
- 테이블 항목으로 **프레임 번호** 와 **유효-무효 비트** 가 저장되어 있다.
  - 프레임 번호: 각 페이지가 저장되어있는 메모리 주소값
  - 유효-무효 비트(Valid-Invalid bit): 각 페이지가 메모리에 적재되었는지 아닌지 표시
    - 1인 경우
      - 해당 page table의 인덱스는 접근이 가능하다.
      - 실제 물리 메모리에 올라와 있다.
    - 0인 경우
      - 해당 page table의 인덱스는 접근이 불가능하다.
      - 현재 디스크에 존재한다.
#### 2) Demanding Paging을 수행하는 과정
``` 
1. CPU는 trap을 발생시켜 운영체제에게 알린다. 
2. 운영체제는 CPU의 동작을 잠시 멈춘다.
3. 운영체제는 page table을 확인하여, 가상 메모리(Disk)에 페이지가 존재하는지 확인하고 없으면 프로세스를 종료한다.
4. 현재 물리 메모리에 비어있는 프레임(free frame)이 있는지 찾는다.
5. 비어있는 프레임이 없다면, 페이지 교체 알고리즘을 사용하여 공간을 만든다.
6. 비어있는 프레임에 해당 페이지를 로드하고, page table을 업데이트한다.
7. 중단되었던 CPU를 다시 시작한다.
```

|Before|After|
|:---:|:---:|
|![paging1](https://kahee.github.io/assets/post_img/191226-2.png)|![paging2](https://user-images.githubusercontent.com/34755287/57119451-47043400-6da5-11e9-9ca3-d0b250683bf0.png)|

1. P1가 CPU를 점유하여 실행되고 있다.
2. CPU에서 P1의 3번째 페이지에 접근한다.
3. page table을 확인한다. valid bit가 0이다.
4. CPU에 인터럽트 신호를 발생하여 운영체제 내부의 ISR로 점프한다.
5. 디스크 내부에서 P1의 3번째 페이지를 물리 메모리에 비어있는 프레임으로 할당한다.