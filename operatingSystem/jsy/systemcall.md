# :question: System call

#### reference
https://luckyyowu.tistory.com/2<br>
https://velog.io/@adam2/%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8
<hr>

## Question
1. [시스템 콜에 대해 설명해주세요.](#1-system-call시스템-호출)
- 시스템 콜이란 일반 응용프로그램이 시스템의 자원을 사용하여 작업하기 위해, 커널에 접근해야 할 때 사용되는 인터페이스입니다.
- 일반 응용프로그램이 malloc 함수를 사용하여 메모리 할당을 요청할 때, 시스템 콜을 호출하여 커널 모드로 전환하여 메모리 값을 전달받을 수 있습니다.
- 또한, cp 명령어를 사용하여 파일을 복사하고자 할 때, 파일을 접근할 수 있는지 검사하기 위해, 시스템 콜을 호출합니다. 이때, 파일이 존재하지 않는다면 에러가 발생하고 종료 시에도 시스템 콜이 호출됩니다.
<br><br>

2. [프로세스가 종료되는 두 가지 조건에 대해 설명해주세요.]()
<hr>

## :nerd_face:	What I study
### 1. System call(시스템 호출)
- 함수호출이긴 하나, 자신의 주소 공간을 거스르는 영역에 존재하는 함수를 호출하는 것
- 자신의 프로그램이 아닌, **커널**이라는 다른 프로그램의 주소 공간에 존재하는 함수를 호출하는 것
  - 주소 공간 자체가 다른 곳으로 이동해야 한다.
  - 프로세스가 하드웨어에 접근해서 필요한 기능을 수행할 수 있도록 한다.
  - 하드웨어와 응용 프로그램 사이에서 인터페이스를 제공한다.
  - cf) 일반적인 process 함수 호출 과정: 자신의 스택에 복귀 주소를 저장한 후 호출된 함수 위치로 점프한다. 
- system call은 운영체제에서 일반적인 사용자 모드가 아닌 커널 모드에서 동작하도록 한다.
  - 일반 응용프로그램이 시스템의 자원을 사용하여 작업하고자 할 때, system call을 사용한다.
- 즉, system call은 **커널 모드**의 기능을 사용자 모드가 접근하게 도와주는 기능이라고 할 수 있다.

#### 1) 사용자 모드
- 시스템 자원이나 하드웨어를 직접적으로 컨트롤 할 수 없다.
- 명령어의 일부와 하드웨어 기능의 일부만 사용할 수 있다.
- 일반 응용프로그램이 동작하는 모드
#### 2) 커널 모드
- 프로세서의 모든 명령을 처리하고 시스템의 자원이나 하드웨어를 직접적으로 엑세스하여 컨트롤한다.
- 실제 장치 드라이버나 운영체제 프로그램이 구동하는 모드
- 시스템에 중요한 영향을 미치는 연산은 커널 모드에서만 실행 가능하도록 하여 보안을 유지하도록 했다.
#### 3) 동작 방식
```
1. 프로세스가 system call 호출
2. trap이 발생하여 커널 모드에 진입한다. 이때, 현재 상태를 저장한다.
3. 요청받은 system call을 수행한다.
4. 사용자 모드로 돌아간다. 이때, 저장해둔 이전 상태로 복원된다.
```
#### 4) System call 유형
1. 프로세서 제어 : 프로세서 특권 모드를 사용해 직접적으로 프로세서를 제어 가능
   - 새로운 프로세스 실행 ```exec```, 프로세스 생성 ```fork```, 자식 프로세스가 끝날 때까지 대기 ```wait```, <br>종료 ```exit```, 강제 종료 ```kill``` ```break``` ```ctrl + c```, <br> 프로세스 중지, 프로세스 적재, 프로세스 속성 획득 및 설정, 메모리 할당 및 해제 ```malloc```
2. 파일 조작
   - 파일을 생성하거나 삭제, 파일 열기 ```open```, 파일 읽기 ```read```, 파일 쓰기 ```write```, <br>파일 닫기, 파일 재배치, 파일 속성 획득 및 설정
3. 장치 관리 : 장치 요구 및 장치 해제, 읽기, 쓰기, 재배치, 장치 속성 획득 및 설정, 장치의 논리적 부착 및 분리
4. 정보 유지: 시간과 날짜의 설정과 획득, 시스템 데이터 설정과 획득, 프로세스 파일, 장치 속성의 설정 및 획득
5. 통신: 통신 연결의 생성 및 제거, 메시지의 송수신, 상태 정보 전달, 공유 메모리에서 다른 프로세스 소유 메모리 접근
<br><br>

### 2. Kernel
- 운영체제의 핵심 부분으로, 항상 메모리에 올라가 있다.
- 하드웨어와 응용 프로그램 사이의 인터페이스를 제공하여, 응용 프로그램이 하드웨어에서부터 오는 자원을 관리하고 사용할 수 있도록 해준다.
- 즉, 프로세스가 하드웨어에 직접 접근해서 필요한 기능을 사용할 수 있게 해준다.
<br><br>

### 3. Interrupt
- CPU가 실행중인 프로세스에 예외상황을 발생시켜, 실행중인 프로세스를 중단하고 다른 프로세스를 수행하도록 하는 것
  1. CPU는 매 시점 메모리에서 순차적으로 현재 점유 중인 프로세스의 다음 명령을 읽어와 실행한다.
     - CPU는 매번 PC(Program Counter)가 가리키는 곳에 있는 명령을 수행하는 일밖에 하지 않는다.
     - 그러므로, 현재 점유 중인 프로세스로부터 CPU를 뺐어서 CPU가 다른 프로세스를 실행하도록 하기 위해 추가 작업이 필요하다 -> Interrupt
  2. CPU 내에는 인터럽트 라인이 있다. 인터럽트를 발생시키기 위해, 하드웨어/소프트웨어는 **CPU 내에 있는 인터럽트 라인을 세팅하여 인터럽트를 발생시킨다.**
  3. CPU는 매번 명령을 수행하기 전, 인터럽트 라인이 세팅되어 있는지 확인한다.
  4. 만약 인터럽트 라인에 신호가 들어와있다면, 하던 명령을 멈추고 인터럽트와 관련된 작업을 먼저 처리한다.

#### 1) 동작 방식
- 실행 중인 프로세스A가 있다고 가정하자.
```
1. 프로세스A는 system call을 통해 인터럽트를 발생시킨다.
2. CPU는 현재 진행 중인 기계어 코드를 완료한다.
3. 현재까지 수행중이었던 상태를 해당 프로세스의 PCB에 저장한다. (ex. 수행중이던 메모리 주소, 레지스터 값 등)
4. PC에 다음에 실행할 명령의 주소를 저장한다.
5. 인터럽트 벡터를 읽고, ISR 주소값을 얻는다.
6. 얻어낸 ISR 주소로 점프하여 루틴을 실행한다.
7. 해당 코드를 실행한다.
8. 인터럽트한 일이 다 처리되면, 이전에 수행중이던 레지스터를 복원한다.
9. ISR 끝에 IRET 명령어에 의해 인터럽트가 해제된다.
10. IRET 명령어가 실행되면, 이전에 수행중이던 PC 값을 복원하여 이전 실행 위치로 되돌아간다.
```
- 인터럽트 벡터: 인터럽트 발생시 처리해야 할 인터럽트 핸들러의 주소를 보관하고 있는 테이블
- ISR (Interrupt Service Routine): 실제 인터럽트를 처리하기 위한 루틴으로, 인터럽트 핸들러라고도 한다.
  - 운영체제의 code 영역에는 인터럽트별로 처리해야할 내용이 이미 프로그램되어 있다.

#### 2) 종류
- 하드웨어 인터럽트
  - CPU가 아닌 다른 하드웨어 장치가 CPU에게 어떤 사실을 알려주거나, CPU 서비스를 요청해야 할 경우 발생시킨다.
  - ex. 정전, 전원 공급 이상, 하드웨어 오류, 타이머 인터럽트, 하드웨어 I/O 장치
- 소프트웨어 인터럽트
  - 외부가 아닌 CPU 내부에서 자신이 실행한 명령이나, 명령 실행과 관련된 모듈이 변화하는 경우 발생시킨다.
  - 소프트웨어가 스스로 인터럽트 라인을 세팅하며 동작한다.
  - ex. 허가되지 않은 메모리 주소 참조, 0으로 나누는 경우, system call, page fault

#### 3) 왜 interrupt 메커니즘이 필요할까?
- 입출력 연산이 CPU 명령 수행속도보다 현저히 느리다. 
- 하드웨어로 지원을 받아야 하는 제약이 있지만, 폴링에 비해 신속하게 대응하는 것이 가능하다.
- 따라서, 인터럽트는 CPU와 I/O의 속도 차이를 극복하기 위해 필요하다.
